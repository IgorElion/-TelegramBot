# -*- coding: utf-8 -*-
"""
Bot Telegram 2 para envio de sinais em canais separados por idioma.
Versão independente que não depende mais do Bot 1.
Os sinais serão enviados da seguinte forma:
- Canal Português: -1002424874613
- Canal Inglês: -1002453956387
- Canal Espanhol: -1002446547846
O bot enviará 1 sinal por hora no minuto 13.
"""

# Importaes necessrias
import traceback
import socket
import pytz
from datetime import datetime, timedelta, time as dt_time
import json
import random
import time
import schedule
import requests
import logging
import sys
import os
from functools import lru_cache
import telebot
import threading
from datetime import time as datetime_time

# Definição da variável global assets
assets = {}

# Definição de outras variáveis globais
ultimo_ativo = None
ultimo_signal = None

# Configuração do logger específico para o Bot 2
BOT2_LOGGER = logging.getLogger("bot2")
BOT2_LOGGER.setLevel(logging.INFO)
bot2_formatter = logging.Formatter(
    "%(asctime)s - BOT2 - %(levelname)s - %(message)s")

# Evitar duplicação de handlers
if not BOT2_LOGGER.handlers:
    bot2_file_handler = logging.FileHandler("bot_telegram_bot2_logs.log")
    bot2_file_handler.setFormatter(bot2_formatter)
    BOT2_LOGGER.addHandler(bot2_file_handler)

    bot2_console_handler = logging.StreamHandler()
    bot2_console_handler.setFormatter(bot2_formatter)
    BOT2_LOGGER.addHandler(bot2_console_handler)

# Credenciais Telegram
BOT2_TOKEN = "7997585882:AAFDyG-BYskj1gyAbh17X5jd6DDClXdluww"

# Inicialização do bot
bot2 = telebot.TeleBot(BOT2_TOKEN)

# Configuração dos canais para cada idioma
BOT2_CANAIS_CONFIG = {
    "pt": ["-1002424874613"],  # Canal para mensagens em português
    "en": ["-1002453956387"],  # Canal para mensagens em inglês
    "es": ["-1002446547846"]   # Canal para mensagens em espanhol
}

# Configurações adicionais por idioma
CONFIGS_IDIOMA = {
    "pt": {
        "link_corretora": "https://trade.xxbroker.com/register?aff=741613&aff_model=revenue&afftrack=",
        "fuso_horario": "America/Sao_Paulo",  # Brasil (UTC-3)
    },
    "en": {
        "link_corretora": "https://trade.xxbroker.com/register?aff=741727&aff_model=revenue&afftrack=",
        "fuso_horario": "America/New_York",  # EUA (UTC-5 ou UTC-4 no horário de verão)
    },
    "es": {
        "link_corretora": "https://trade.xxbroker.com/register?aff=741726&aff_model=revenue&afftrack=",
        "fuso_horario": "Europe/Madrid",  # Espanha (UTC+1 ou UTC+2 no horário de verão)
    }
}

# Lista de IDs dos canais para facilitar iterao
BOT2_CHAT_IDS = []
for idioma, chats in BOT2_CANAIS_CONFIG.items():
    BOT2_CHAT_IDS.extend(chats)

# Base URL do GitHub para os arquivos
GITHUB_BASE_URL = "https://raw.githubusercontent.com/IgorElion/-TelegramBot/main/"

# Dicionário de mapeamento de caminhos dos GIFs válidos
GIFS_VALIDOS = {
    "gif_especial_pt": "videos/gif_especial/pt/especial.gif",
    "pos_sinal_pt": "videos/pos_sinal/pt/padrao.gif",
    "pos_sinal_en": "videos/pos_sinal/en/padrao.gif",
    "pos_sinal_es": "videos/pos_sinal/es/padrao.gif",
    "promo_pt": "videos/promo/pt/promo.gif",
    "promo_en": "videos/promo/en/promo.gif",
    "promo_es": "videos/promo/es/promo.gif",
}

# URLs alternativas para GIFs (utilizadas apenas na verificação)
ALTERNATIVE_GIFS = {}

# URLs diretas para GIFs do Giphy
URLS_GIFS_DIRETAS = {
    "promo_pt": "https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZGhqMmNqOWFpbTQ2cjNxMzF1YncxcnAwdTFvN2o1NWRmc2dvYXZ6bCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/whPiIq21hxXuJn7WVX/giphy.gif",
    "promo_en": "https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZGhqMmNqOWFpbTQ2cjNxMzF1YncxcnAwdTFvN2o1NWRmc2dvYXZ6bCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/whPiIq21hxXuJn7WVX/giphy.gif",
    "promo_es": "https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZGhqMmNqOWFpbTQ2cjNxMzF1YncxcnAwdTFvN2o1NWRmc2dvYXZ6bCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/whPiIq21hxXuJn7WVX/giphy.gif",
    "pos_sinal_padrao": "https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExdjZjb3hyMDVqOHAyb2xvZTgxZzVpb2ZscWE3M2RzOHY5Z3VzZTc2YiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/eWbGux0IXOygZ7m2Of/giphy.gif",
    "gif_especial_pt": "https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExN2tzdzB4bjNjaWo4bm9zdDR3d2g4bmQzeHRqcWx6MTQxYTA1cjRoeCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/E2EknXAKA5ac8gKVxu/giphy.gif"
}

# ID para compatibilidade com cdigo existente
BOT2_CHAT_ID_CORRETO = BOT2_CHAT_IDS[0]  # Usar o primeiro canal como padro

# Limite de sinais por hora
BOT2_LIMITE_SINAIS_POR_HORA = 1

# Categorias de ativos
ATIVOS_CATEGORIAS = {
    "Binary": [],
    "Blitz": [],
    "Digital": [
        "Gold/Silver (OTC)",
        "Worldcoin (OTC)",
        "USD/THB (OTC)",
        "ETH/USD (OTC)",
        "CHF/JPY (OTC)",
        "Pepe (OTC)",
        "GBP/AUD (OTC)",
        "GBP/CHF",
        "GBP/CAD (OTC)",
        "EUR/JPY (OTC)",
        "AUD/CHF",
        "GER 30 (OTC)",
        "AUD/CHF (OTC)",
        "EUR/AUD",
        "USD/CAD (OTC)",
        "BTC/USD",
        "Amazon/Ebay (OTC)",
        "Coca-Cola Company (OTC)",
        "AIG (OTC)",
        "Amazon/Alibaba (OTC)",
        "Bitcoin Cash (OTC)",
        "AUD/USD",
        "DASH (OTC)",
        "BTC/USD (OTC)",
        "SP 35 (OTC)",
        "TRUMP Coin (OTC)",
        "US 100 (OTC)",
        "EUR/CAD (OTC)",
        "HK 33 (OTC)",
        "Alphabet/Microsoft (OTC)",
        "1000Sats (OTC)",
        "USD/ZAR (OTC)",
        "Litecoin (OTC)",
        "Hamster Kombat (OTC)",
        "USD Currency Index (OTC)",
        "AUS 200 (OTC)",
        "USD/CAD",
        "MELANIA Coin (OTC)",
        "JP 225 (OTC)",
        "AUD/CAD (OTC)",
        "AUD/JPY (OTC)",
        "US 500 (OTC)",
    ],
}

# Configurações de horários específicos para cada ativo
HORARIOS_PADRAO = {
    "USD/BRL_OTC": {
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-00:45", "01:15-23:59"],
        "Wednesday": ["00:00-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "USOUSD_OTC": {
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-23:59"],
        "Thursday": ["00:00-06:00", "06:30-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "BTC/USD_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Google_OTC": {
        "Monday": ["00:00-15:30", "16:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-15:30", "16:00-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-15:30", "16:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "EUR/JPY_OTC": {
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-01:00", "01:15-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "ETH/USD_OTC": {
        "Monday": ["00:00-19:45", "20:15-23:59"],
        "Tuesday": ["00:00-19:45", "20:15-23:59"],
        "Wednesday": ["00:00-19:45", "20:15-23:59"],
        "Thursday": ["00:00-19:45", "20:15-23:59"],
        "Friday": ["00:00-19:45", "20:15-23:59"],
        "Saturday": ["00:00-19:45", "20:15-23:59"],
        "Sunday": ["00:00-19:45", "20:15-23:59"],
    },
    "MELANIA_COIN_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "EUR/GBP_OTC": {
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-01:00", "01:15-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "Apple_OTC": {
        "Monday": ["00:00-15:30", "16:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-15:30", "16:00-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-15:30", "16:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "Amazon_OTC": {
        "Monday": ["00:00-15:30", "16:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-15:30", "16:00-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-15:30", "16:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "TRUM_Coin_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Nike_Inc_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "DOGECOIN_OTC": {
        "Monday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Tuesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Wednesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Thursday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Friday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Saturday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Sunday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
    },
    "Tesla_OTC": {
        "Monday": ["00:00-15:30", "16:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-15:30", "16:00-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-15:30", "16:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "SOL/USD_OTC": {
        "Monday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Tuesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Wednesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Thursday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Friday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Saturday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Sunday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
    },
    "1000Sats_OTC": {
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "XAUUSD_OTC": {
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-23:59"],
        "Thursday": ["00:00-06:00", "06:30-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "McDonalds_Corporation_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Meta_OTC": {
        "Monday": ["00:00-15:30", "16:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-15:30", "16:00-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-15:30", "16:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "Coca_Cola_Company_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "CARDANO_OTC": {
        "Monday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Tuesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Wednesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Thursday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Friday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Saturday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Sunday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
    },
    "EUR/USD_OTC": {
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-01:00", "01:15-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "PEN/USD_OTC": {
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-00:45", "01:15-23:59"],
        "Wednesday": ["00:00-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "Bitcoin_Cash_OTC": {
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "AUD/CAD_OTC": {
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-01:00", "01:15-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "Tesla/Ford_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "US_100_OTC": {
        "Monday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Tuesday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Wednesday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Thursday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
    },
    "FR_40_OTC": {  # Novo horrio para FR 40 (OTC)
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "AUS_200_OTC": {  # Atualizado com horrios especficos
        "Monday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Saturday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Sunday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
    },
    "US_500_OTC": {  # Atualizado com horrios especficos
        "Monday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Tuesday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Wednesday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Thursday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
    },
    "EU_50_OTC": {  # Novo ativo com horrios especficos
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Gold": {  # Novo ativo com horrios especficos
        "Monday": ["04:00-16:00"],
        "Tuesday": ["04:00-16:00"],
        "Wednesday": ["04:00-16:00"],
        "Thursday": ["04:00-16:00"],
        "Friday": ["04:00-16:00"],
        "Saturday": [],
        "Sunday": [],
    },
    "XAUUSD_OTC": {  # Atualizado com horrios especficos
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-23:59"],
        "Thursday": ["00:00-06:00", "06:10-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "US2000_OTC": {  # Novo ativo com horrios especficos
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Gala_OTC": {  # Novo horrio especfico para Gala (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Floki_OTC": {  # Novo horrio especfico para Floki (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Graph_OTC": {  # Novo horrio especfico para Graph (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Intel_IBM_OTC": {  # Novo horrio para Intel/IBM (OTC)
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Pyth_OTC": {  # Atualizado para Pyth (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "IOTA_OTC": {  # Atualizado para IOTA (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "DOGECOIN_OTC": {  # Atualizado para DOGECOIN (OTC)
        "Monday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Tuesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Wednesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Thursday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Friday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Saturday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Sunday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
    },
    "Sei_OTC": {  # Atualizado para Sei (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Decentraland_OTC": {  # Atualizado para Decentraland (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "PEN_USD_OTC": {  # Atualizado para PEN/USD (OTC)
        "Monday": ["00:00-23:59"],
        "Tuesday": ["00:00-00:45", "01:15-23:59"],
        "Wednesday": ["00:00-23:59"],
        "Thursday": ["00:00-23:59"],
        "Friday": ["00:00-23:59"],
        "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "Sandbox_OTC": {  # Atualizado para Sandbox (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "TRON_USD_OTC": {  # Atualizado para TRON/USD (OTC)
        "Monday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Tuesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Wednesday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Thursday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Friday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Saturday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
        "Sunday": ["00:00-05:45", "06:15-17:45", "18:15-23:59"],
    },
    "Ripple_OTC": {  # Atualizado para Ripple (OTC)
        "Monday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Saturday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Sunday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
    },
    "NEAR_OTC": {  # Atualizado para NEAR (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Arbitrum_OTC": {  # Atualizado para Arbitrum (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Polygon_OTC": {  # Atualizado para Polygon (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "EOS_OTC": {  # Atualizado para EOS (OTC)
        "Monday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Saturday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Sunday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
    },
    "Alphabet_Microsoft_OTC": {  # Novo horrio para Alphabet/Microsoft (OTC)
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Jupiter_OTC": {  # Atualizado para Jupiter (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Dogwifhat_OTC": {  # Novo horrio para Dogwifhat (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Immutable_OTC": {  # Atualizado para Immutable (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Stacks_OTC": {  # Atualizado para Stacks (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Pepe_OTC": {  # Atualizado para Pepe (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "Ronin_OTC": {  # Atualizado para Ronin (OTC)
        "Monday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Tuesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Wednesday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Thursday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Friday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Saturday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
        "Sunday": ["00:00-05:05", "05:10-12:05", "12:10-23:59"],
    },
    "USD/CAD": {
        "Monday": ["03:00-15:00"],
        "Tuesday": ["03:00-15:00", "21:00-23:59"],
        "Wednesday": ["00:00-15:00"],
        "Thursday": ["03:00-15:00"],
        "Friday": ["03:00-15:00"],
        "Saturday": [],
        "Sunday": [],
    },
    "MELANIA_Coin_OTC": {  # J existe, mantendo a mesma configurao
    },
    "Gold/Silver_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Worldcoin_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "USD/THB_OTC": {
        "Monday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Saturday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Sunday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
    },
    "ETH/USD_OTC": {
        "Monday": ["00:00-19:45", "20:15-23:59"],
        "Tuesday": ["00:00-19:45", "20:15-23:59"],
        "Wednesday": ["00:00-19:45", "20:15-23:59"],
        "Thursday": ["00:00-19:45", "20:15-23:59"],
        "Friday": ["00:00-19:45", "20:15-23:59"],
        "Saturday": ["00:00-19:45", "20:15-23:59"],
        "Sunday": ["00:00-19:45", "20:15-23:59"],
    },
    "CHF/JPY_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Pepe_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "GBP/AUD_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "GBP/CHF": {
        "Monday": ["00:00-16:00"],
        "Tuesday": ["00:00-16:00"],
        "Wednesday": ["00:00-16:00"],
        "Thursday": ["00:00-16:00"],
        "Friday": ["00:00-14:00"],
                "Saturday": [],
        "Sunday": [],
    },
    "GBP/CAD_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "EUR/JPY_OTC": {
                "Monday": ["00:00-23:59"],
                "Tuesday": ["00:00-23:59"],
        "Wednesday": ["00:00-01:00", "01:15-23:59"],
                "Thursday": ["00:00-23:59"],
                "Friday": ["00:00-23:59"],
                "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-23:59"],
    },
    "AUD/CHF": {
        "Monday": ["00:00-16:00"],
        "Tuesday": ["00:00-16:00"],
        "Wednesday": ["00:00-16:00"],
        "Thursday": ["00:00-16:00"],
        "Friday": ["00:00-14:00"],
                "Saturday": [],
        "Sunday": [],
    },
    "GER_30_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "AUD/CHF_OTC": {
        "Monday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Saturday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Sunday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
    },
    "EUR/AUD": {
        "Monday": ["00:00-16:00"],
        "Tuesday": ["00:00-16:00"],
        "Wednesday": ["00:00-16:00"],
        "Thursday": ["00:00-16:00"],
        "Friday": ["00:00-14:00"],
                "Saturday": [],
        "Sunday": [],
    },
    "USD/CAD_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "BTC/USD": {
        "Monday": ["03:00-15:00"],
        "Tuesday": ["03:00-15:00"],
        "Wednesday": ["03:00-15:00"],
        "Thursday": ["03:00-15:00"],
        "Friday": ["03:00-15:00"],
        "Saturday": [],
        "Sunday": [],
    },
    "Amazon/Ebay_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Coca-Cola_Company_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "AIG_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Amazon/Alibaba_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "Bitcoin_Cash_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "USD Currency Index_OTC": {
        "Monday": ["00:00-10:00", "10:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-10:00", "10:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-10:00", "10:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-10:00", "10:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-10:00", "10:30-18:00"],
        "Saturday": [],
        "Sunday": ["19:00-23:59"],
    },
    "AUS_200_OTC": {  # J existe, mas atualizando para os novos horrios
        "Monday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Saturday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Sunday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
    },
    "JP_225_OTC": {
        "Monday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Saturday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Sunday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
    },
    "AUD/CAD_OTC": {  # J existe, atualizando a configurao
        "Monday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Tuesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Wednesday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Thursday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Friday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Saturday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
        "Sunday": ["00:00-03:00", "03:30-22:00", "22:30-23:59"],
    },
    "AUD/JPY_OTC": {
        "Monday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Tuesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Wednesday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Thursday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Friday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Saturday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
        "Sunday": ["00:00-05:00", "05:30-12:00", "12:30-23:59"],
    },
    "US_500_OTC": {  # J existe, atualizando a configurao
        "Monday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Tuesday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Wednesday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
        "Thursday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
                "Friday": ["00:00-23:59"],
                "Saturday": ["00:00-23:59"],
        "Sunday": ["00:00-11:30", "12:00-17:30", "18:00-23:59"],
    },
}

# URLs diretas para GIFs
URLS_GIFS_DIRETAS = {
    "promo_pt": "https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZGhqMmNqOWFpbTQ2cjNxMzF1YncxcnAwdTFvN2o1NWRmc2dvYXZ6bCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/whPiIq21hxXuJn7WVX/giphy.gif",
    "promo_en": "https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZGhqMmNqOWFpbTQ2cjNxMzF1YncxcnAwdTFvN2o1NWRmc2dvYXZ6bCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/whPiIq21hxXuJn7WVX/giphy.gif",
    "promo_es": "https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZGhqMmNqOWFpbTQ2cjNxMzF1YncxcnAwdTFvN2o1NWRmc2dvYXZ6bCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/whPiIq21hxXuJn7WVX/giphy.gif",
    "pos_sinal_padrao": "https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExdjZjb3hyMDVqOHAyb2xvZTgxZzVpb2ZscWE3M2RzOHY5Z3VzZTc2YiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/eWbGux0IXOygZ7m2Of/giphy.gif",
    "gif_especial_pt": "https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExN2tzdzB4bjNjaWo4bm9zdDR3d2g4bmQzeHRqcWx6MTQxYTA1cjRoeCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/E2EknXAKA5ac8gKVxu/giphy.gif"
}

# Adicionar variável global para controlar mensagem de perda enviada por dia
mensagem_perda_enviada_hoje = False

# Variáveis para controle de sinais
ultimo_sinal_enviado = None

def adicionar_blitz(lista_ativos):
    for ativo in lista_ativos:
        if ativo in HORARIOS_PADRAO:
            assets[ativo] = HORARIOS_PADRAO[ativo]
        else:
            assets[ativo] = {
                "Monday": ["00:00-23:59"],
                "Tuesday": ["00:00-23:59"],
                "Wednesday": ["00:00-23:59"],
                "Thursday": ["00:00-23:59"],
                "Friday": ["00:00-23:59"],
                "Saturday": ["00:00-23:59"],
                "Sunday": ["00:00-23:59"],
            }
        ATIVOS_CATEGORIAS[ativo] = "Blitz"


# Exemplos de como adicionar ativos (comentado para referncia)
# adicionar_forex(["EUR/USD", "GBP/USD"])
# adicionar_crypto(["BTC/USD", "ETH/USD"])
# adicionar_stocks(["AAPL", "MSFT"])

# Funo para parsear os horrios


@lru_cache(maxsize=128)
def parse_time_range(time_str):
    """
    Converte uma string de intervalo de tempo (e.g. "09:30-16:00") para um par de time objects.
    """
    start_str, end_str = time_str.split("-")
    start_time = datetime.strptime(start_str, "%H:%M").time()
    end_time = datetime.strptime(end_str, "%H:%M").time()
    return start_time, end_time


# Funo para verificar disponibilidade de ativos


def is_asset_available(asset, current_time=None, current_day=None):
    """
    Verifica se um ativo está disponível para negociação em um determinado horário.

    Args:
        asset (str): O nome do ativo a ser verificado.
        current_time (datetime, optional): O horário atual. Se None, usará o horário atual do sistema.
        current_day (str, optional): O dia atual. Se None, será determinado a partir do horário atual.

    Returns:
        bool: True se o ativo estiver disponível, False caso contrário.
    """
    # Se o horário atual não foi fornecido, usar o horário de Brasília
    if current_time is None:
        current_time = bot2_obter_hora_brasilia()

    # Determinar o dia da semana atual
    if current_day is None:
        # segunda-feira, terça-feira, etc.
        current_day = current_time.strftime("%A")

    # Transformar o horário atual em um formato de string para comparação
    current_time_str = current_time.strftime("%H:%M")

    # Se o ativo tiver um horário personalizado, verificar nesse horário
    asset_key = asset.replace(" ", "_").replace("/", "_")
    if asset_key in HORARIOS_PADRAO:
        day_ranges = HORARIOS_PADRAO[asset_key].get(current_day, [])
        if not day_ranges:
            return False  # Se não há horários definidos para este dia, o ativo não está disponível

        # Verificar se o horário atual está dentro de algum dos intervalos
        # definidos
        for time_range in day_ranges:
            start_time, end_time = time_range.split("-")
            if start_time <= current_time_str <= end_time:
                return True

        return False  # Se não está em nenhum intervalo, não está disponível

    # Se o ativo não tem um horário específico definido, ele está sempre
    # disponível
    return True


def bot2_verificar_horario_ativo(ativo, categoria):
    """
    Verifica se um ativo está disponível no horário atual.

    Args:
        ativo (str): O nome do ativo a verificar
        categoria (str): A categoria do ativo (Binary, Blitz, Digital)

    Returns:
        bool: True se o ativo estiver disponível, False caso contrário
    """
    # Obter o horário atual em Brasília
    agora = bot2_obter_hora_brasilia()
    dia_semana = agora.strftime("%A")

    # Verificar disponibilidade usando a função is_asset_available
    return is_asset_available(ativo, agora, dia_semana)


# Funo para obter hora no fuso horário de Brasília (específica para Bot 2)


def bot2_obter_hora_brasilia():
    """
    Retorna a hora atual no fuso horário de Brasília.
    """
    fuso_horario_brasilia = pytz.timezone("America/Sao_Paulo")
    return datetime.now(fuso_horario_brasilia)


def bot2_verificar_disponibilidade():
    """
    Verifica quais ativos estão disponíveis para negociação neste momento.
    Retorna: lista de strings com os nomes dos ativos disponíveis.
    """
    global ASSETS_INFO
    global BOT2_LOGGER
    
    ativos_disponiveis = []
    horario_atual = datetime.now()
    dia_atual = horario_atual.strftime('%A')
    
    try:
        BOT2_LOGGER.debug(f"🕒 Verificando disponibilidade em: {horario_atual.strftime('%Y-%m-%d %H:%M:%S')}")
        BOT2_LOGGER.debug(f"📅 Dia atual: {dia_atual}")
        
        # Para cada ativo, verificar se está dentro do horário de negociação
        for ativo, info in ASSETS_INFO.items():
            if dia_atual in info:
                horarios = info[dia_atual]
                
                # Verificar se o ativo está disponível no momento atual
                disponivel = False
                for intervalo in horarios:
                    hora_inicio_str, hora_fim_str = intervalo.split(' - ')
                    
                    # Converter as strings para objetos datetime
                    hora_inicio = datetime.strptime(hora_inicio_str, '%H:%M').time()
                    hora_fim = datetime.strptime(hora_fim_str, '%H:%M').time()
                    hora_atual = horario_atual.time()
                    
                    # Verificar se o horário atual está dentro do intervalo
                    if hora_inicio <= hora_atual <= hora_fim:
                        disponivel = True
                        break
                
                if disponivel:
                    ativos_disponiveis.append(ativo)
                    BOT2_LOGGER.debug(f"✅ Ativo disponível: {ativo}")
                else:
                    BOT2_LOGGER.debug(f"❌ Ativo indisponível: {ativo}")
            else:
                BOT2_LOGGER.debug(f"🚫 Ativo {ativo} não negocia às {dia_atual}")
        
        BOT2_LOGGER.info(f"📊 Total de ativos disponíveis: {len(ativos_disponiveis)}/{len(ASSETS_INFO)}")
        return ativos_disponiveis
        
    except Exception as e:
        BOT2_LOGGER.error(f"❌ Erro ao verificar disponibilidade: {str(e)}")
        BOT2_LOGGER.error(f"🔍 Detalhes: {traceback.format_exc()}")
        return []


def bot2_gerar_sinal_aleatorio():
    """Gera um sinal de trading aleatório com base nas categorias disponíveis."""
    global assets, BOT2_LOGGER

    try:
        # Obter a hora atual em Brasília
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        
        BOT2_LOGGER.info(f"[SINAL-GERADOR][{horario_atual}] 🔄 Iniciando geração de sinal aleatório...")

        # Selecionar apenas uma categoria para todos os sinais (Digital)
        categoria = "Digital"

        # Verificar quais ativos estão disponíveis neste momento
        ativos_disponiveis = bot2_verificar_disponibilidade()
        
        if not ativos_disponiveis:
            BOT2_LOGGER.warning(f"[SINAL-GERADOR][{horario_atual}] ⚠️ Nenhum ativo disponível no momento atual")
            
            # Como fallback, usar a lista completa de ativos da categoria
            ativos_na_categoria = ATIVOS_CATEGORIAS[categoria]
            BOT2_LOGGER.info(f"[SINAL-GERADOR][{horario_atual}] ℹ️ Usando lista completa de ativos ({len(ativos_na_categoria)}) como fallback")
        else:
            ativos_na_categoria = ativos_disponiveis
            BOT2_LOGGER.info(f"[SINAL-GERADOR][{horario_atual}] ✅ {len(ativos_disponiveis)} ativos disponíveis para seleção")

        if not ativos_na_categoria:
            BOT2_LOGGER.error(f"[SINAL-GERADOR][{horario_atual}] ❌ Nenhum ativo disponível na categoria {categoria}")
            return None

        # Escolher aleatoriamente um ativo da categoria
        ativo = random.choice(ativos_na_categoria)
        BOT2_LOGGER.info(f"[SINAL-GERADOR][{horario_atual}] 🎯 Ativo selecionado: {ativo}")

        # Escolher aleatoriamente a direção (CALL ou PUT)
        direcao = random.choice(["CALL", "PUT"])
        BOT2_LOGGER.info(f"[SINAL-GERADOR][{horario_atual}] 🎯 Direção selecionada: {direcao}")

        # Definir o tempo de expiração fixo em 5 minutos para todos os sinais
        tempo_expiracao_minutos = 5
        expiracao_time = bot2_obter_hora_brasilia() + timedelta(
            minutes=tempo_expiracao_minutos
        )
        expiracao_texto = f"🕒 Expiração: {tempo_expiracao_minutos} minutos ({expiracao_time.strftime('%H:%M')})"
        BOT2_LOGGER.info(f"[SINAL-GERADOR][{horario_atual}] ⏱️ Tempo de expiração: {tempo_expiracao_minutos} minutos (até {expiracao_time.strftime('%H:%M:%S')})")

        # Verificar se o ativo está realmente disponível no horário atual
        if not bot2_verificar_horario_ativo(ativo, categoria):
            BOT2_LOGGER.warning(f"[SINAL-GERADOR][{horario_atual}] ⚠️ Ativo {ativo} não está disponível no horário atual, mas foi selecionado como fallback")

        # Registrar nos logs que um sinal foi gerado
        BOT2_LOGGER.info(
            f"[SINAL-GERADOR][{horario_atual}] ✅ Sinal gerado com sucesso: Ativo={ativo}, Direção={direcao}, Expiração={tempo_expiracao_minutos}min, Categoria={categoria}"
        )

        # Retornar o sinal como um dicionário
        return {
            "ativo": ativo,
            "direcao": direcao,
            "tempo_expiracao_minutos": tempo_expiracao_minutos,
            "expiracao_texto": expiracao_texto,
            "categoria": categoria,
        }

    except Exception as e:
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        BOT2_LOGGER.error(f"[SINAL-GERADOR][{horario_atual}] ❌ Erro ao gerar sinal aleatório: {str(e)}")
        BOT2_LOGGER.error(f"[SINAL-GERADOR][{horario_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
        return None


# Funo para obter hora no fuso horário específico (a partir da hora de
# Brasília)


def bot2_converter_fuso_horario(hora_brasilia, fuso_destino):
    """
    Converte uma hora do fuso horário de Brasília para o fuso horário de destino.
    
    Args:
        hora_brasilia (datetime): Hora no fuso horário de Brasília
        fuso_destino (str): Nome do fuso horário de destino (ex: 'America/New_York')
        
    Returns:
        datetime: Hora convertida para o fuso horário de destino
    """
    # Garantir que hora_brasilia tenha informações de fuso horário
    fuso_horario_brasilia = pytz.timezone("America/Sao_Paulo")
    
    # Se a hora não tiver informação de fuso, adicionar
    if hora_brasilia.tzinfo is None:
        hora_brasilia = fuso_horario_brasilia.localize(hora_brasilia)
    
    # Converter para o fuso horário de destino
    fuso_destino_tz = pytz.timezone(fuso_destino)
    hora_destino = hora_brasilia.astimezone(fuso_destino_tz)
    
    return hora_destino


def bot2_formatar_mensagem(sinal, hora_formatada, idioma):
    """
    Formata a mensagem de sinal para envio, conforme o idioma especificado.
    """
    global BOT2_LOGGER, CONFIGS_IDIOMA
    
    try:
        BOT2_LOGGER.info(
            f"Formatando mensagem com: ativo={sinal['ativo']}, direção={sinal['direcao']}, "
            + f"categoria={sinal['categoria']}, tempo={sinal['tempo_expiracao_minutos']}, idioma={idioma}"
        )
        
        # Obter configuração para o idioma
        config_idioma = CONFIGS_IDIOMA.get(idioma, CONFIGS_IDIOMA["pt"])
        
        # Obter informações do sinal
        ativo = sinal["ativo"]
        direcao = sinal["direcao"]
        categoria = sinal["categoria"]
        tempo_expiracao_minutos = sinal["tempo_expiracao_minutos"]
        
        # Definir o fuso horário de acordo com o idioma
        fuso_horario = config_idioma.get("fuso_horario", "America/Sao_Paulo")
        
        # Obter link da corretora específico para o idioma
        link_corretora = config_idioma.get("link_corretora", "")
        
        # Tratar nome do ativo para exibição
        nome_ativo_exibicao = ativo.replace("_", " ")
        # Ajustar a parte OTC para não ter parênteses duplicados
        if "OTC" in nome_ativo_exibicao:
            nome_ativo_exibicao = nome_ativo_exibicao.replace("OTC", "(OTC)")
            # Garantir que não temos parênteses duplicados
            nome_ativo_exibicao = nome_ativo_exibicao.replace("((OTC))", "(OTC)")
        
        # Determinar emoji baseado na direção
        emoji = "🟩" if direcao.upper() == "CALL" else "🟥"
        
        # Definir texto da direção para cada idioma
        if direcao.upper() == "CALL":
            action_pt = "COMPRA"
            action_en = "BUY"
            action_es = "COMPRA"
        else:
            action_pt = "VENDA"
            action_en = "SELL"
            action_es = "VENTA"
        
        # Ajustar o formato da hora dependendo do que foi recebido
        if len(hora_formatada) <= 5:  # Formato HH:MM
            hora_formatada = hora_formatada + ":00"  # Adicionar segundos como 00
            
        # Converter a hora de entrada para o formato correto
        try:
            hora_entrada = datetime.strptime(hora_formatada, "%H:%M:%S")
        except ValueError:
            try:
                # Tentar formato alternativo se o primeiro falhar
                hora_entrada = datetime.strptime(hora_formatada, "%H:%M")
            except ValueError:
                BOT2_LOGGER.error(f"Formato de hora inválido: {hora_formatada}. Usando hora atual.")
                # Usar a hora atual como fallback
                hora_entrada = datetime.now().replace(microsecond=0)

        # Ajustar para o horário atual se hora_entrada for apenas um time, não um datetime
        if isinstance(hora_entrada, datetime_time):
            agora = datetime.now()
            hora_entrada = datetime(
                agora.year, agora.month, agora.day, 
                hora_entrada.hour, hora_entrada.minute, hora_entrada.second
            )
        
        # MODIFICAÇÃO: Ajustar o horário para 2 minutos à frente para ser exibido ao lado de COMPRA/VENDA
        hora_exibicao = hora_entrada + timedelta(minutes=2)
        hora_exibicao_formatada = hora_exibicao.strftime("%H:%M")
        
        # Calcular as horas de expiração e gales com base na hora_exibicao
        hora_expiracao = hora_exibicao + timedelta(minutes=tempo_expiracao_minutos)
        hora_gale1 = hora_expiracao + timedelta(minutes=5)
        hora_gale2 = hora_gale1 + timedelta(minutes=5)
        hora_gale3 = hora_gale2 + timedelta(minutes=5)
        
        # Formatar as horas para exibição sem os segundos
        hora_entrada_formatada = hora_entrada.strftime("%H:%M")
        hora_expiracao_formatada = hora_expiracao.strftime("%H:%M")
        hora_gale1_formatada = hora_gale1.strftime("%H:%M")
        hora_gale2_formatada = hora_gale2.strftime("%H:%M")
        hora_gale3_formatada = hora_gale3.strftime("%H:%M")
        
        # Converter as horas para o fuso horário específico do idioma
        if fuso_horario != "America/Sao_Paulo":
            # Converter para o fuso horário do idioma
            hora_exibicao_formatada = bot2_converter_fuso_horario(
                hora_exibicao, fuso_horario
            ).strftime("%H:%M")
            hora_entrada_formatada = bot2_converter_fuso_horario(
                hora_entrada, fuso_horario
            ).strftime("%H:%M")
            hora_expiracao_formatada = bot2_converter_fuso_horario(
                hora_expiracao, fuso_horario
            ).strftime("%H:%M")
            hora_gale1_formatada = bot2_converter_fuso_horario(
                hora_gale1, fuso_horario
            ).strftime("%H:%M")
            hora_gale2_formatada = bot2_converter_fuso_horario(
                hora_gale2, fuso_horario
            ).strftime("%H:%M")
            hora_gale3_formatada = bot2_converter_fuso_horario(
                hora_gale3, fuso_horario
            ).strftime("%H:%M")
        
        # Registrar os horários convertidos para o log
        BOT2_LOGGER.info(
            f"Horários convertidos para fuso {fuso_horario}: Exibição={hora_exibicao_formatada}, Entrada={hora_entrada_formatada}, "
            + f"Expiração={hora_expiracao_formatada}, Gale1={hora_gale1_formatada}, "
            + f"Gale2={hora_gale2_formatada}, Gale3={hora_gale3_formatada}"
        )

        # Formatação para singular ou plural de "minuto" baseado no tempo de
        # expiração
        texto_minutos_pt = "minuto" if tempo_expiracao_minutos == 1 else "minutos"
        texto_minutos_en = "minute" if tempo_expiracao_minutos == 1 else "minutes"
        texto_minutos_es = "minuto" if tempo_expiracao_minutos == 1 else "minutos"

        # Configurar links baseados no idioma
        if idioma == "pt":
            # Não sobrescrever link_corretora se já estiver definido
            if not link_corretora:
                link_corretora = (
                    "https://trade.xxbroker.com/register?aff=741613&aff_model=revenue&afftrack="
                )
            link_video = "https://t.me/trendingbrazil/215"
            texto_corretora = "Clique para abrir a corretora"
            texto_video = "Clique aqui"
            texto_tempo = "TEMPO PARA"
            texto_gale1 = "1º GALE — TEMPO PARA"
            texto_gale2 = "2º GALE TEMPO PARA"
            texto_gale3 = "3º GALE TEMPO PARA"
        elif idioma == "en":
            # Não sobrescrever link_corretora se já estiver definido
            if not link_corretora:
                link_corretora = (
                    "https://trade.xxbroker.com/register?aff=741727&aff_model=revenue&afftrack="
                )
            link_video = "https://t.me/trendingenglish/226"
            texto_corretora = "Click to open broker"
            texto_video = "Click here"
            texto_tempo = "TIME UNTIL"
            texto_gale1 = "1st GALE — TIME UNTIL"
            texto_gale2 = "2nd GALE TIME UNTIL"
            texto_gale3 = "3rd GALE TIME UNTIL"
        else:  # espanhol
            # Não sobrescrever link_corretora se já estiver definido
            if not link_corretora:
                link_corretora = (
                    "https://trade.xxbroker.com/register?aff=741726&aff_model=revenue&afftrack="
                )
            link_video = "https://t.me/trendingespanish/212"
            texto_corretora = "Haga clic para abrir el corredor"
            texto_video = "Haga clic aquí"
            texto_tempo = "TIEMPO HASTA"
            texto_gale1 = "1º GALE — TIEMPO HASTA"
            texto_gale2 = "2º GALE TIEMPO HASTA"
            texto_gale3 = "3º GALE TIEMPO HASTA"
        
        # Determinar a categoria de exibição (Binary, Digital)
        categoria_exibicao = "Binary"
        if isinstance(categoria, list) and len(categoria) > 0:
            # Escolher apenas um item da lista para exibir (o primeiro)
            categoria_exibicao = categoria[0]
        else:
            categoria_exibicao = categoria  # Usar o valor de categoria diretamente

        # Mensagem em PT
        mensagem_pt = (
            f"💰{tempo_expiracao_minutos} {texto_minutos_pt} de expiração\n"
            f"{nome_ativo_exibicao};{hora_exibicao_formatada};{action_pt} {emoji} {categoria_exibicao}\n\n"
                f"🕐{texto_tempo} {hora_expiracao_formatada}\n\n"
                f"{texto_gale1} {hora_gale1_formatada}\n"
                f"{texto_gale2} {hora_gale2_formatada}\n"
                f"{texto_gale3} {hora_gale3_formatada}\n\n"
            f'📲 <a href="{link_corretora}" title="">Clique para abrir a corretora</a>\n'
            f'🙋‍♂️ Não sabe operar ainda? <a href="{link_video}" title="">Clique aqui</a>'
        )
                
        # Mensagem em EN
        mensagem_en = (
            f"💰{tempo_expiracao_minutos} {texto_minutos_en} expiration\n"
            f"{nome_ativo_exibicao};{hora_exibicao_formatada};{action_en} {emoji} {categoria_exibicao}\n\n"
                f"🕐{texto_tempo} {hora_expiracao_formatada}\n\n"
                f"{texto_gale1} {hora_gale1_formatada}\n"
                f"{texto_gale2} {hora_gale2_formatada}\n"
                f"{texto_gale3} {hora_gale3_formatada}\n\n"
            f'📲 <a href="{link_corretora}" title="">Click to open broker</a>\n'
            f'🙋‍♂️ Don\'t know how to trade yet? <a href="{link_video}" title="">Click here</a>'
        )
                
        # Mensagem em ES
        mensagem_es = (
            f"💰{tempo_expiracao_minutos} {texto_minutos_es} de expiración\n"
            f"{nome_ativo_exibicao};{hora_exibicao_formatada};{action_es} {emoji} {categoria_exibicao}\n\n"
                f"🕐{texto_tempo} {hora_expiracao_formatada}\n\n"
                f"{texto_gale1} {hora_gale1_formatada}\n"
                f"{texto_gale2} {hora_gale2_formatada}\n"
                f"{texto_gale3} {hora_gale3_formatada}\n\n"
            f'📲 <a href="{link_corretora}" title="">Haga clic para abrir el corredor</a>\n'
            f'🙋‍♂️ ¿No sabe operar todavía? <a href="{link_video}" title="">Haga clic aquí</a>'
        )
                
        # Verificar se há algum texto não esperado antes de retornar a mensagem
        if idioma == "pt":
            mensagem_final = mensagem_pt
        elif idioma == "en":
            mensagem_final = mensagem_en
        elif idioma == "es":
            mensagem_final = mensagem_es
        else:  # Padrão para qualquer outro idioma (português)
            mensagem_final = mensagem_pt
            
        BOT2_LOGGER.info(
            f"Mensagem formatada final para idioma {idioma}: {mensagem_final}")
        return mensagem_final

    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao formatar mensagem: {str(e)}")
        traceback.print_exc()
        return None


def bot2_registrar_envio(ativo, direcao, categoria):
    """
    Registra o envio de um sinal no banco de dados.
    Implementao futura: Aqui voc adicionaria o cdigo para registrar o envio no banco de dados.
    """
    pass


# Inicializao do Bot 2 quando este arquivo for executado
bot2_sinais_agendados = False
bot2_contador_sinais = 0  # Contador para rastrear quantos sinais foram enviados
BOT2_ATIVOS_CATEGORIAS = {}  # Inicialização de categorias de ativos

# URLs promocionais
XXBROKER_URL = (
    "https://trade.xxbroker.com/register?aff=741613&aff_model=revenue&afftrack="
)
VIDEO_TELEGRAM_URL = "https://t.me/trendingbrazil/215"
VIDEO_TELEGRAM_ES_URL = "https://t.me/trendingespanish/212"
VIDEO_TELEGRAM_EN_URL = "https://t.me/trendingenglish/226"

# Base directory para os arquivos do projeto
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Definindo diretrios para os vdeos
VIDEOS_DIR = os.path.join(BASE_DIR, "videos")
os.makedirs(VIDEOS_DIR, exist_ok=True)

# Subdiretrios para organizar os vdeos
VIDEOS_POS_SINAL_DIR = os.path.join(VIDEOS_DIR, "pos_sinal")
VIDEOS_PROMO_DIR = os.path.join(VIDEOS_DIR, "promo")
# Alterado de "especial" para "gif_especial"
VIDEOS_ESPECIAL_DIR = os.path.join(VIDEOS_DIR, "gif_especial")

# Criar os subdiretrios se no existirem
os.makedirs(VIDEOS_POS_SINAL_DIR, exist_ok=True)
os.makedirs(VIDEOS_PROMO_DIR, exist_ok=True)
os.makedirs(VIDEOS_ESPECIAL_DIR, exist_ok=True)

# Diretrios para vdeos ps-sinal em cada idioma
VIDEOS_POS_SINAL_PT_DIR = os.path.join(VIDEOS_POS_SINAL_DIR, "pt")
VIDEOS_POS_SINAL_EN_DIR = os.path.join(VIDEOS_POS_SINAL_DIR, "en")
VIDEOS_POS_SINAL_ES_DIR = os.path.join(VIDEOS_POS_SINAL_DIR, "es")

# Diretrios para vdeos especiais em cada idioma
VIDEOS_ESPECIAL_PT_DIR = os.path.join(VIDEOS_ESPECIAL_DIR, "pt")
VIDEOS_ESPECIAL_EN_DIR = os.path.join(VIDEOS_ESPECIAL_DIR, "en")
VIDEOS_ESPECIAL_ES_DIR = os.path.join(VIDEOS_ESPECIAL_DIR, "es")

# Criar os subdiretrios para cada idioma se no existirem
os.makedirs(VIDEOS_POS_SINAL_PT_DIR, exist_ok=True)
os.makedirs(VIDEOS_POS_SINAL_EN_DIR, exist_ok=True)
os.makedirs(VIDEOS_POS_SINAL_ES_DIR, exist_ok=True)
os.makedirs(VIDEOS_ESPECIAL_PT_DIR, exist_ok=True)
os.makedirs(VIDEOS_ESPECIAL_EN_DIR, exist_ok=True)
os.makedirs(VIDEOS_ESPECIAL_ES_DIR, exist_ok=True)

# URLs dos GIFs diretamente do GitHub (seguindo a estrutura de seu repositório)
VIDEOS_POS_SINAL_GITHUB = {
    "pt": [
        # Vdeo padro em portugus (9/10)
        f"{GITHUB_BASE_URL}videos/pos_sinal/pt/padrão.gif",
        # Vdeo especial em portugus (1/10)
        f"{GITHUB_BASE_URL}videos/pos_sinal/pt/especial.gif",
    ],
    "en": [
        # Vdeo padro em ingls (9/10)
        f"{GITHUB_BASE_URL}videos/pos_sinal/en/padrao.gif",
        # Vdeo especial em ingls (1/10)
        f"{GITHUB_BASE_URL}videos/pos_sinal/en/especial.gif",
    ],
    "es": [
        # Vdeo padro em espanhol (9/10)
        f"{GITHUB_BASE_URL}videos/pos_sinal/es/padrao.gif",
        # Vdeo especial em espanhol (1/10)
        f"{GITHUB_BASE_URL}videos/pos_sinal/es/especial.gif",
    ],
}

# Configurar vdeos ps-sinal especficos para cada idioma (local paths)
VIDEOS_POS_SINAL = {
    "pt": [
        os.path.join(VIDEOS_POS_SINAL_PT_DIR, "padrão.gif"),
        # Vdeo padro em portugus (9/10)
        # Vdeo especial em portugus (1/10)
        os.path.join(VIDEOS_POS_SINAL_PT_DIR, "especial.gif"),
    ],
    "en": [
        os.path.join(VIDEOS_POS_SINAL_EN_DIR, "padrao.gif"),
        # Vdeo padro em ingls (9/10)
        # Vdeo especial em ingls (1/10)
        os.path.join(VIDEOS_POS_SINAL_EN_DIR, "especial.gif"),
    ],
    "es": [
        os.path.join(VIDEOS_POS_SINAL_ES_DIR, "padrao.gif"),
        # Vdeo padro em espanhol (9/10)
        # Vdeo especial em espanhol (1/10)
        os.path.join(VIDEOS_POS_SINAL_ES_DIR, "especial.gif"),
    ],
}

# Vdeo especial a cada 3 sinais (por idioma) - URLs do GitHub
VIDEOS_ESPECIAIS_GITHUB = {
    "pt": f"{GITHUB_BASE_URL}videos/gif_especial/pt/especial.gif",
    "en": f"{GITHUB_BASE_URL}videos/gif_especial/en/especial.gif",
    "es": f"{GITHUB_BASE_URL}videos/gif_especial/es/especial.gif",
}

# Vdeo especial a cada 3 sinais (por idioma) - local paths
VIDEOS_ESPECIAIS = {
    "pt": os.path.join(VIDEOS_ESPECIAL_PT_DIR, "especial.gif"),
    "en": os.path.join(VIDEOS_ESPECIAL_EN_DIR, "especial.gif"),
    "es": os.path.join(VIDEOS_ESPECIAL_ES_DIR, "especial.gif"),
}

# Vdeos promocionais por idioma - URLs do GitHub
VIDEOS_PROMO_GITHUB = {
    "pt": f"{GITHUB_BASE_URL}videos/promo/pt/promo.gif",
    "en": f"{GITHUB_BASE_URL}videos/promo/en/promo.gif",
    "es": f"{GITHUB_BASE_URL}videos/promo/es/promo.gif",
}

# Vdeos promocionais por idioma - local paths
VIDEOS_PROMO = {
    "pt": os.path.join(VIDEOS_PROMO_DIR, "pt", "promo.gif"),
    "en": os.path.join(VIDEOS_PROMO_DIR, "en", "promo.gif"),
    "es": os.path.join(VIDEOS_PROMO_DIR, "es", "promo.gif"),
}

# Logs para diagnstico
print(f"VIDEOS_DIR: {VIDEOS_DIR}")
print(f"VIDEOS_ESPECIAL_DIR: {VIDEOS_ESPECIAL_DIR}")
print(f"VIDEOS_ESPECIAL_PT_DIR: {VIDEOS_ESPECIAL_PT_DIR}")

# Caminho para o vdeo do GIF especial PT
VIDEO_GIF_ESPECIAL_PT = os.path.join(VIDEOS_ESPECIAL_PT_DIR, "especial.gif")
print(f"VIDEO_GIF_ESPECIAL_PT: {VIDEO_GIF_ESPECIAL_PT}")

# Contador para controle dos GIFs ps-sinal
contador_pos_sinal = 0
contador_desde_ultimo_especial = 0

# Adicionar variveis para controle da imagem especial diria
horario_especial_diario = None
imagem_especial_ja_enviada_hoje = False

# Funo para definir o horrio especial dirio


def definir_horario_especial_diario():
    global horario_especial_diario, imagem_especial_ja_enviada_hoje, mensagem_perda_enviada_hoje
    
    # Reseta o status de envio da imagem especial e mensagem de perda
    imagem_especial_ja_enviada_hoje = False
    mensagem_perda_enviada_hoje = False
    
    # Define um horrio aleatrio entre 0 e 23 horas
    horas_disponiveis = list(range(0, 24))
    hora_aleatoria = random.choice(horas_disponiveis)
    
    # Definir o mesmo minuto usado para o envio de sinais
    minuto_envio = 13
    
    # Define o horrio especial para hoje
    horario_atual = bot2_obter_hora_brasilia()
    horario_especial_diario = horario_atual.replace(
        hour=hora_aleatoria, 
        minute=minuto_envio,  # Mesmo minuto usado para envio de sinais
        second=0, 
        microsecond=0,
    )
    
    BOT2_LOGGER.info(
        f"Horário especial diário definido para: {horario_especial_diario.strftime('%H:%M')}"
    )
    
    # Se o horrio j passou hoje, reagenda para amanh
    if horario_especial_diario < horario_atual:
        horario_especial_diario = horario_especial_diario + timedelta(days=1)
        BOT2_LOGGER.info(
            f"Horário já passou hoje, reagendado para amanhã: {horario_especial_diario.strftime('%H:%M')}"
        )


# Agendar a redefinio do horrio especial dirio  meia-noite


def agendar_redefinicao_horario_especial():
    schedule.every().day.at("00:01").do(definir_horario_especial_diario)
    BOT2_LOGGER.info(
        "Agendada redefinição do horário especial diário para meia-noite e um minuto"
    )


# Chamar a funo no incio para definir o horrio especial para hoje
definir_horario_especial_diario()
agendar_redefinicao_horario_especial()


def verificar_url_gif(url):
    """
    Verifica se a URL do GIF está acessível.
    
    Args:
        url (str): A URL do GIF a ser verificada
        
    Returns:
        tuple: (url_a_usar, is_valid) onde url_a_usar é a URL verificada ou alternativa,
               e is_valid é um booleano indicando se a URL está acessível
    """
    try:
        BOT2_LOGGER.info(f"Verificando URL de GIF: {url}")
        response = requests.head(url, timeout=5)
        
        if response.status_code == 200:
            BOT2_LOGGER.info(f"URL de GIF válida: {url}")
            return url, True
        else:
            BOT2_LOGGER.warning(f"URL de GIF inválida (código {response.status_code}): {url}")
            return url, False
    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao verificar URL {url}: {str(e)}")
        return url, False


def bot2_enviar_gif_pos_sinal(signal=None):
    """Envia um GIF após o resultado do sinal."""
    global BOT2_LOGGER, BOT2_CANAIS_CONFIG, BOT2_TOKEN, CONFIGS_IDIOMA, ultimo_sinal_enviado, bot2, URLS_GIFS_DIRETAS
    
    try:
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        
        BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 🔄 Iniciando envio do GIF pós-sinal")
        
        # Verificar se o sinal existe
        if not signal:
            signal = ultimo_sinal_enviado
        
        if not signal:
            BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] ❌ Não foi possível encontrar o sinal para enviar o GIF")
            return False
        
        # Verifica se o ativo está dentro do horário de operação
        ativo = signal.get('ativo', None)
        categoria = signal.get('categoria', 'Digital')

        BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 🔍 Verificando disponibilidade do ativo {ativo} (categoria: {categoria})")
        if ativo and not bot2_verificar_horario_ativo(ativo, categoria):
            BOT2_LOGGER.warning(
                f"[GIF-POS-SINAL][{horario_atual}] ⚠️ Ativo {ativo} não está dentro do horário de operação. Não enviando GIF pós-sinal")
            return False
        
        # Contar quantas mensagens/GIFs foram enviados
        envios_com_sucesso = 0
        
        # URL base do GIF pós-sinal (usada como fallback)
        url_base_gif = "https://raw.githubusercontent.com/IgorElion/-TelegramBot/main/videos/pos_sinal"
        
        # Para cada idioma configurado, envia o GIF
        for idioma, chats in BOT2_CANAIS_CONFIG.items():
            if not chats:  # Se não houver chats configurados para este idioma, pula
                BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] ℹ️ Nenhum chat configurado para o idioma {idioma}, pulando")
                continue
            
            BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 📤 Preparando envio para {len(chats)} chat(s) no idioma {idioma}")
            
            # Definir a URL do GIF com base no idioma
            gif_url = ""
            if idioma == "pt":
                gif_url = f"{url_base_gif}/pt/180398513446716419%20(7).webp"
            elif idioma == "en":
                gif_url = f"{url_base_gif}/en/180398513446716419%20(7).webp"
            elif idioma == "es":
                gif_url = f"{url_base_gif}/es/180398513446716419%20(7).webp"
            else:
                # Caso não encontre o idioma, usa o PT como padrão
                gif_url = f"{url_base_gif}/pt/180398513446716419%20(7).webp"
                BOT2_LOGGER.warning(f"[GIF-POS-SINAL][{horario_atual}] ⚠️ Idioma {idioma} não reconhecido, usando PT como padrão")
            
            for chat_id in chats:
                try:
                    BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 🔗 Usando GIF: {gif_url} para idioma {idioma}")
                    BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 📦 Preparando envio para chat_id: {chat_id}")
                    
                    try:
                        # Baixar o arquivo para enviar como arquivo em vez de URL
                        BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] ⬇️ Baixando arquivo")
                        arquivo_resposta = requests.get(gif_url, stream=True, timeout=15)
                        
                        if arquivo_resposta.status_code == 200:
                            # Criar um arquivo temporário no formato correto
                            extensao = ".webp"  # Sempre usar .webp para o arquivo do GitHub
                            
                            nome_arquivo_temp = f"temp_gif_{idioma}_{random.randint(1000, 9999)}{extensao}"
                            
                            # Salvar o arquivo temporariamente
                            with open(nome_arquivo_temp, 'wb') as f:
                                f.write(arquivo_resposta.content)
                            
                            BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 💾 Arquivo baixado como {nome_arquivo_temp}")
                            
                            # Abrir o arquivo e enviar como animação
                            with open(nome_arquivo_temp, 'rb') as f_gif:
                                # Enviar o GIF como animação diretamente do arquivo nas dimensões especificadas
                                BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 🚀 Enviando arquivo como animação")
                                bot2.send_animation(
                                    chat_id=chat_id,
                                    animation=f_gif,
                                    caption="",
                                    parse_mode="HTML",
                                    width=208,
                                    height=84
                                )
                            
                            # Remover o arquivo temporário
                            try:
                                os.remove(nome_arquivo_temp)
                                BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 🗑️ Arquivo temporário removido")
                            except:
                                BOT2_LOGGER.warning(f"[GIF-POS-SINAL][{horario_atual}] ⚠️ Não foi possível remover o arquivo temporário")
                            
                            BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] ✅ GIF enviado com sucesso para {chat_id}")
                            envios_com_sucesso += 1
                        else:
                            BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] ❌ Erro ao baixar o arquivo. Status: {arquivo_resposta.status_code}")
                            # Se falhar com o idioma específico, tenta com o PT como fallback
                            fallback_url = f"{url_base_gif}/pt/180398513446716419%20(7).webp"
                            BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 🔄 Tentando fallback com URL direta: {fallback_url}")
                            bot2.send_animation(
                                chat_id=chat_id,
                                animation=fallback_url,
                                caption="",
                                parse_mode="HTML",
                                width=208,
                                height=84
                            )
                            BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] ✅ GIF enviado com sucesso (fallback)")
                            envios_com_sucesso += 1
                    except Exception as download_error:
                        BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] ❌ Erro ao baixar/enviar: {str(download_error)}")
                        # Tentar enviar diretamente com a URL como fallback
                        fallback_url = f"{url_base_gif}/pt/180398513446716419%20(7).webp"
                        BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] 🔄 Tentando segundo fallback com URL direta: {fallback_url}")
                        try:
                            bot2.send_animation(
                                chat_id=chat_id,
                                animation=fallback_url,
                                caption="",
                                parse_mode="HTML",
                                width=208,
                                height=84
                            )
                            BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] ✅ GIF enviado com sucesso (segundo fallback)")
                            envios_com_sucesso += 1
                        except Exception as final_error:
                            BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] ❌ Falha total no envio: {str(final_error)}")
                            BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
                    
                except Exception as e:
                    BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] ❌ Erro no chat {chat_id}: {str(e)}")
                    BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")

                    if "rights to send" in str(e).lower():
                        BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] 🚫 Bot sem permissões no canal {chat_id}")

        if envios_com_sucesso > 0:
            BOT2_LOGGER.info(f"[GIF-POS-SINAL][{horario_atual}] ✅ Total de {envios_com_sucesso} GIFs enviados com sucesso")
            return True
        else:
            BOT2_LOGGER.warning(f"[GIF-POS-SINAL][{horario_atual}] ⚠️ Nenhum GIF foi enviado")
            return False
    
    except Exception as e:
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] ❌ Erro geral: {str(e)}")
        BOT2_LOGGER.error(f"[GIF-POS-SINAL][{horario_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
        traceback.print_exc()
        return False


def bot2_send_message(texto, chat_id=None, disable_web_page_preview=True, parse_mode=None, verificar_disponibilidade=False):
    """
    Envia uma mensagem para um chat específico ou para o grupo configurado.
    Retorna: dict com a resposta da API ou None em caso de erro.
    
    Parâmetros:
        texto (str): O texto da mensagem a ser enviada
        chat_id (str, opcional): O ID do chat para onde enviar. Se None, usa o padrão
        disable_web_page_preview (bool, opcional): Se deve desativar a pré-visualização de links
        parse_mode (str, opcional): Modo de formatação (HTML, Markdown)
        verificar_disponibilidade (bool, opcional): Se deve verificar a disponibilidade de ativos antes de enviar
    """
    global TG_GROUP_ID_BOT2
    global BOT2_ID
    global BOT2_LOGGER
    
    try:
        # Obter hora de Brasília para logs mais precisos
        hora_atual = bot2_obter_hora_brasilia().strftime("%H:%M:%S")
        BOT2_LOGGER.info(f"[MSG][{hora_atual}] 🔄 Iniciando processo de envio de mensagem")
        
        # Verificar disponibilidade de ativos antes de enviar o sinal (opcional)
        if verificar_disponibilidade:
            BOT2_LOGGER.info(f"[MSG][{hora_atual}] 🔍 Verificando disponibilidade de ativos antes de enviar mensagem...")
            ativos_disponiveis = bot2_verificar_disponibilidade()
            n_disponiveis = len(ativos_disponiveis)
            
            if n_disponiveis == 0:
                BOT2_LOGGER.warning(f"[MSG][{hora_atual}] ⚠️ ALERTA: Nenhum ativo disponível para envio de mensagem!")
                # Continuamos mesmo sem ativos disponíveis, para mensagens que não dependem disso
            elif n_disponiveis < 5:
                BOT2_LOGGER.warning(f"[MSG][{hora_atual}] ⚠️ Poucos ativos disponíveis: {n_disponiveis}")
                BOT2_LOGGER.info(f"[MSG][{hora_atual}] 📊 Ativos disponíveis: {', '.join(ativos_disponiveis)}")
            else:
                BOT2_LOGGER.info(f"[MSG][{hora_atual}] ✅ {n_disponiveis} ativos disponíveis para operação")
                # Mostrar os primeiros 5 ativos como exemplo
                BOT2_LOGGER.info(f"[MSG][{hora_atual}] 📊 Exemplos: {', '.join(ativos_disponiveis[:5])}...")
        
        # Determinar o chat_id a ser usado
        if not chat_id:
            chat_id = TG_GROUP_ID_BOT2
            BOT2_LOGGER.info(f"[MSG][{hora_atual}] ℹ️ Usando chat_id padrão: {chat_id}")
        else:
            BOT2_LOGGER.info(f"[MSG][{hora_atual}] ℹ️ Usando chat_id fornecido: {chat_id}")
        
        # Montar os parâmetros da requisição
        params = {
            'chat_id': chat_id,
            'text': texto,
            'disable_web_page_preview': disable_web_page_preview,
        }
        
        # Adicionar o parse_mode se fornecido
        if parse_mode:
            params['parse_mode'] = parse_mode
            BOT2_LOGGER.info(f"[MSG][{hora_atual}] ℹ️ Usando parse_mode: {parse_mode}")
            
        # Construir a URL da API
        url = f"https://api.telegram.org/bot{BOT2_TOKEN}/sendMessage"
        
        # Adicionar logs para debug
        BOT2_LOGGER.info(f"[MSG][{hora_atual}] 📤 Enviando mensagem para chat_id: {chat_id}")
        
        # Registrar o tamanho da mensagem e os primeiros caracteres
        tamanho_mensagem = len(texto)
        preview = texto[:50] + "..." if tamanho_mensagem > 50 else texto
        BOT2_LOGGER.info(f"[MSG][{hora_atual}] 📝 Tamanho da mensagem: {tamanho_mensagem} caracteres")
        BOT2_LOGGER.debug(f"[MSG][{hora_atual}] 📝 Conteúdo: {preview}")
        
        # Medir tempo de resposta da API
        tempo_inicio = time.time()
        
        # Fazer a requisição para a API
        response = requests.post(url, data=params, timeout=15)
        
        # Calcular tempo de resposta
        tempo_resposta = (time.time() - tempo_inicio) * 1000  # em milissegundos
        
        # Verificar a resposta
        if response.status_code == 200:
            BOT2_LOGGER.info(f"[MSG][{hora_atual}] ✅ Mensagem enviada com sucesso! Latência: {tempo_resposta:.1f}ms")
            return response.json()
        else:
            BOT2_LOGGER.error(f"[MSG][{hora_atual}] ❌ Erro ao enviar mensagem. Status: {response.status_code}")
            BOT2_LOGGER.error(f"[MSG][{hora_atual}] 🔍 Resposta da API: {response.text}")
            return None
            
    except requests.exceptions.Timeout:
        BOT2_LOGGER.error(f"[MSG][{hora_atual}] ⏱️ Timeout ao enviar mensagem para {chat_id}")
        return None
    except requests.exceptions.ConnectionError:
        BOT2_LOGGER.error(f"[MSG][{hora_atual}] 🌐 Erro de conexão ao enviar mensagem para {chat_id}")
        return None
    except Exception as e:
        hora_atual = bot2_obter_hora_brasilia().strftime("%H:%M:%S")
        BOT2_LOGGER.error(f"[MSG][{hora_atual}] ❌ Exceção ao enviar mensagem: {str(e)}")
        BOT2_LOGGER.error(f"[MSG][{hora_atual}] 🔍 Detalhes: {traceback.format_exc()}")
        return None


def bot2_iniciar_ciclo_sinais():
    """
    Agenda o envio de sinais do Bot 2 a cada hora no minuto 13.
    """
    global bot2_sinais_agendados, BOT2_LOGGER
    
    try:
        # Limpar agendamentos anteriores de sinais
        schedule.clear("bot2_sinais")
        
        # Configurar para enviar sempre no minuto 13 de cada hora
        minuto_envio = 13
        
        # Agendar a cada hora no minuto 13
        schedule.every().hour.at(f":{minuto_envio:02d}").do(bot2_gerar_e_enviar_sinal).tag("bot2_sinais")
        
        BOT2_LOGGER.info(f"Sinal do Bot 2 agendado para o minuto {minuto_envio} de cada hora")
        BOT2_LOGGER.info("Configuração atual: 1 sinal por hora, apenas ativos Digital, expiração de 5 minutos")
        BOT2_LOGGER.info(f"Total de ativos da categoria Digital disponíveis: {len(ATIVOS_CATEGORIAS['Digital'])}")
        
        # Verificar próximo horário de envio
        agora = bot2_obter_hora_brasilia()
        hora_atual = agora.hour
        minuto_atual = agora.minute
        
        if minuto_atual >= minuto_envio:
            # Se já passou do minuto 13 dessa hora, o próximo será na próxima hora
            proximo_envio = f"{(hora_atual + 1) % 24:02d}:{minuto_envio:02d}"
        else:
            # Se ainda não chegou no minuto 13 dessa hora, será nessa hora mesmo
            proximo_envio = f"{hora_atual:02d}:{minuto_envio:02d}"
            
        BOT2_LOGGER.info(f"Próximo sinal agendado para: {proximo_envio}")
        
        # Verificar se estamos próximos do horário de envio (dentro de 1 minuto)
        if (minuto_atual == minuto_envio) or (minuto_atual == minuto_envio - 1):
            BOT2_LOGGER.info(f"Estamos próximos do horário de envio! Enviando sinal imediatamente...")
            bot2_gerar_e_enviar_sinal()
        
        bot2_sinais_agendados = True
        return True
        
    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao iniciar ciclo de sinais do Bot 2: {str(e)}")
        traceback.print_exc()
        bot2_sinais_agendados = False
        return False


def iniciar_ambos_bots():
    """
    Inicializa o Bot 2 e mantém o programa em execução,
    tratando as tarefas agendadas periodicamente.
    """
    global bot2_sinais_agendados, BOT2_LOGGER
    
    try:
        # Verificar configurações antes de iniciar
        if not verificar_configuracoes_bot():
            BOT2_LOGGER.error("❌ Falha na verificação de configurações. Corrija os erros antes de iniciar o bot.")
            return False
            
        # Iniciar o Bot 2
        if not bot2_sinais_agendados:
            bot2_iniciar_ciclo_sinais()  # Agendar sinais para o Bot 2
            
        BOT2_LOGGER.info("=== BOT 2 INICIADO COM SUCESSO! ===")
        BOT2_LOGGER.info("⏳ Aguardando envio de sinais nos horários programados...")
        
        # Verificar ativos disponíveis ao iniciar o bot
        BOT2_LOGGER.info("🔍 Verificando ativos disponíveis ao iniciar...")
        ativos_disponiveis = bot2_verificar_disponibilidade()
        BOT2_LOGGER.info(f"✅ Verificação inicial concluída: {len(ativos_disponiveis)} ativos disponíveis")
        
        # Registrar estatísticas iniciais
        estatisticas = {
            "inicia_execucao": bot2_obter_hora_brasilia(),
            "sinais_enviados": 0,
            "sinais_falha": 0,
            "ultimo_sinal": None,
            "ultimo_check": bot2_obter_hora_brasilia()
        }
        
        # Loop principal para manter o programa em execução
        while True:
            try:
                # Executar tarefas agendadas
                schedule.run_pending()
                
                # A cada minuto, verificar o status do sistema
                agora = bot2_obter_hora_brasilia()
                if (agora - estatisticas["ultimo_check"]).total_seconds() >= 60:
                    tempo_execucao = (agora - estatisticas["inicia_execucao"]).total_seconds() / 60.0
                    BOT2_LOGGER.info(f"[STATUS] ⏱️ Bot em execução há {tempo_execucao:.1f} minutos | Sinais enviados: {estatisticas['sinais_enviados']} | Falhas: {estatisticas['sinais_falha']}")
                    
                    # Verificar se há jobs agendados
                    jobs = schedule.get_jobs("bot2_sinais")
                    if not jobs:
                        BOT2_LOGGER.warning("[STATUS] ⚠️ Nenhum job de sinal agendado! Reagendando...")
                        bot2_iniciar_ciclo_sinais()
                    else:
                        # Mostrar próximo horário agendado
                        proximo_job = jobs[0]
                        BOT2_LOGGER.info(f"[STATUS] 📆 Próximo sinal agendado: {proximo_job}")
                
                    # Atualizar timestamp de verificação
                    estatisticas["ultimo_check"] = agora
                
                # Pausa para não sobrecarregar a CPU
                time.sleep(1)
            except KeyboardInterrupt:
                print("\nPrograma encerrado manualmente.")
                BOT2_LOGGER.info("🛑 Programa encerrado manualmente.")
                sys.exit(0)
            except Exception as e:
                BOT2_LOGGER.error(f"❌ Erro no loop principal: {str(e)}")
                BOT2_LOGGER.error(f"🔍 Detalhes do erro: {traceback.format_exc()}")
        
        return True
    except Exception as e:
        BOT2_LOGGER.error(f"❌ Erro crítico ao iniciar bots: {str(e)}")
        BOT2_LOGGER.error(f"🔍 Detalhes do erro: {traceback.format_exc()}")
        return False

# Função para enviar sinal manualmente (para testes)
def enviar_sinal_manual():
    """Função para enviar um sinal manualmente para testes."""
    try:
        BOT2_LOGGER.info("Enviando sinal manualmente para teste...")
        resultado = bot2_gerar_e_enviar_sinal()
        
        if resultado:
            BOT2_LOGGER.info("Sinal manual enviado com sucesso!")
            return True
        else:
            BOT2_LOGGER.error("Falha ao enviar sinal manual.")
            return False
    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao enviar sinal manual: {str(e)}")
        traceback.print_exc()
        return False


def verificar_agendamento_sinais():
    """Verifica se os sinais estão agendados corretamente e reagenda se necessário."""
    global bot2_sinais_agendados, BOT2_LOGGER
    
    try:
        BOT2_LOGGER.info("Verificando agendamento de sinais...")
        
        # Verificar se há jobs agendados com a tag "bot2_sinais"
        jobs_sinais = schedule.get_jobs("bot2_sinais")
        
        if not jobs_sinais:
            BOT2_LOGGER.warning("Nenhum job de sinal agendado! Reagendando...")
            bot2_iniciar_ciclo_sinais()
            return True
        else:
            BOT2_LOGGER.info(f"Encontrados {len(jobs_sinais)} jobs de sinais agendados")
            for job in jobs_sinais:
                BOT2_LOGGER.info(f"Job agendado: {job}")
            return True
    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao verificar agendamento de sinais: {str(e)}")
        traceback.print_exc()
        return False


def verificar_configuracoes_bot():
    """
    Verifica se as configurações do bot estão corretas.
    Retorna: True se tudo estiver correto, False caso contrário
    """
    global BOT2_TOKEN, BOT2_CANAIS_CONFIG, ATIVOS_CATEGORIAS, BOT2_LOGGER
    
    try:
        BOT2_LOGGER.info("Verificando configurações do bot...")
        
        # Verificar se o token foi configurado
        if not BOT2_TOKEN:
            BOT2_LOGGER.error("Token do bot não configurado!")
            return False
        BOT2_LOGGER.info(f"Token do bot configurado: {BOT2_TOKEN[:5]}...{BOT2_TOKEN[-5:]}")
        
        # Verificar se há canais configurados
        if not BOT2_CANAIS_CONFIG:
            BOT2_LOGGER.error("Nenhum canal configurado!")
            return False
            
        total_canais = sum(len(chats) for chats in BOT2_CANAIS_CONFIG.values())
        BOT2_LOGGER.info(f"Total de canais configurados: {total_canais}")
        
        # Verificar cada idioma
        for idioma, chats in BOT2_CANAIS_CONFIG.items():
            BOT2_LOGGER.info(f"Canais para idioma '{idioma}': {len(chats)}")
        
        # Verificar se há ativos configurados
        if not ATIVOS_CATEGORIAS or not ATIVOS_CATEGORIAS.get("Digital"):
            BOT2_LOGGER.error("Nenhum ativo configurado para a categoria Digital!")
            return False
            
        BOT2_LOGGER.info(f"Total de ativos na categoria 'Digital': {len(ATIVOS_CATEGORIAS['Digital'])}")
        
        # Testar a conexão com a API do Telegram
        BOT2_LOGGER.info("Testando conexão com a API do Telegram...")
        try:
            bot_info = bot2.get_me()
            BOT2_LOGGER.info(f"Conexão com API do Telegram OK! Bot: @{bot_info.username} ({bot_info.first_name})")
        except Exception as e:
            BOT2_LOGGER.error(f"Erro ao conectar com a API do Telegram: {str(e)}")
            BOT2_LOGGER.error("Verifique se o token está correto e se há conexão com a internet.")
            raise
        
        BOT2_LOGGER.info("Todas as configurações estão corretas!")
        
        return True
    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao verificar configurações: {str(e)}")
        traceback.print_exc()
        return False


def bot2_enviar_mensagem_abertura_corretora():
    """Envia uma mensagem informando sobre a abertura da corretora para todos os canais configurados."""

    global BOT2_LOGGER, BOT2_CANAIS_CONFIG, BOT2_TOKEN, CONFIGS_IDIOMA

    try:
        # Verificar se a mensagem já foi enviada recentemente (dentro de 10 minutos)
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        
        # Criar uma variável estática para controlar o último envio
        if not hasattr(bot2_enviar_mensagem_abertura_corretora, "ultimo_envio"):
            bot2_enviar_mensagem_abertura_corretora.ultimo_envio = datetime(2000, 1, 1, tzinfo=pytz.timezone("America/Sao_Paulo"))
            
        # Verificar se faz menos de 10 minutos desde o último envio
        intervalo_minimo = timedelta(minutes=10)
        tempo_decorrido = agora - bot2_enviar_mensagem_abertura_corretora.ultimo_envio
        
        if tempo_decorrido < intervalo_minimo:
            BOT2_LOGGER.warning(f"[{horario_atual}] Mensagem de abertura da corretora já foi enviada há {tempo_decorrido.total_seconds()/60:.1f} minutos. Ignorando novo envio.")
            return True  # Retorna True para não interromper a sequência
        
        # Limpar quaisquer agendamentos pendentes para evitar repetições
        schedule.clear("abertura_corretora")
        
        BOT2_LOGGER.info(f"[{horario_atual}] Iniciando envio da mensagem de abertura da corretora")

        # Contar quantas mensagens foram enviadas
        envios_com_sucesso = 0

        # Para cada idioma configurado, envia a mensagem formatada
        for idioma, chats in BOT2_CANAIS_CONFIG.items():
            if not chats:  # Se não houver chats configurados para este idioma, pula
                continue

            # Links específicos por idioma
            if idioma == "pt":
                link_corretora = "https://trade.xxbroker.com/register?aff=741613&aff_model=revenue&afftrack="
            elif idioma == "en":
                link_corretora = "https://trade.xxbroker.com/register?aff=741727&aff_model=revenue&afftrack="
            else:  # es
                link_corretora = "https://trade.xxbroker.com/register?aff=741726&aff_model=revenue&afftrack="

            if idioma == "pt":
                texto_abertura = (
                    "👉🏼Abram a corretora Pessoal\n\n"
                    "⚠️FIQUEM ATENTOS⚠️\n\n"
                    "🔥Cadastre-se na XXBROKER agora mesmo🔥\n\n"
                    f"➡️ <a href=\"{link_corretora}\" title=\"\"><b>CLICANDO AQUI</b></a>"
                )
            elif idioma == "en":
                texto_abertura = (
                    "👉🏼Open the broker everyone\n\n"
                    "⚠️STAY ALERT⚠️\n\n"
                    "🔥Register on XXBROKER right now🔥\n\n"
                    f"➡️ <a href=\"{link_corretora}\" title=\"\"><b>CLICK HERE</b></a>"
                )
            else:  # es
                texto_abertura = (
                    "👉🏼Abran el corredor todos\n\n"
                    "⚠️ESTÉN ATENTOS⚠️\n\n"
                    "🔥Regístrese en XXBROKER ahora mismo🔥\n\n"
                    f"➡️ <a href=\"{link_corretora}\" title=\"\"><b>HAGA CLIC AQUÍ</b></a>"
                )

            for chat_id in chats:
                try:
                    # URL base para a API do Telegram
                    url_base = f"https://api.telegram.org/bot{BOT2_TOKEN}/sendMessage"
                    
                    resposta = requests.post(
                        url_base,
                        json={
                            "chat_id": chat_id,
                            "text": texto_abertura,
                            "parse_mode": "HTML",
                            "disable_web_page_preview": True,
                        },
                        timeout=10,
                    )

                    if resposta.status_code == 200:
                        BOT2_LOGGER.info(
                            f"[{horario_atual}] Mensagem de abertura enviada com sucesso para {chat_id} (idioma: {idioma})"
                        )
                        envios_com_sucesso += 1
                    else:
                        BOT2_LOGGER.error(
                            f"[{horario_atual}] Erro ao enviar mensagem de abertura para {chat_id}: {resposta.text}"
                        )
                except Exception as e:
                    BOT2_LOGGER.error(f"[{horario_atual}] Erro ao enviar mensagem de abertura: {str(e)}")
                    traceback.print_exc()

        BOT2_LOGGER.info(
            f"[{horario_atual}] Total de mensagens de abertura enviadas com sucesso: {envios_com_sucesso}"
        )
        
        # Atualizar o timestamp do último envio
        bot2_enviar_mensagem_abertura_corretora.ultimo_envio = agora
        
        # Limpar novamente quaisquer agendamentos pendentes (por segurança)
        schedule.clear("abertura_corretora")
        
        return envios_com_sucesso > 0
    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao enviar mensagem de abertura: {str(e)}")
        traceback.print_exc()
        return False


def verificar_agendamento_sinais():
    """Verifica se os sinais estão agendados corretamente e reagenda se necessário."""
    global bot2_sinais_agendados, BOT2_LOGGER
    
    try:
        BOT2_LOGGER.info("Verificando agendamento de sinais...")
        
        # Verificar se há jobs agendados com a tag "bot2_sinais"
        jobs_sinais = schedule.get_jobs("bot2_sinais")
        
        if not jobs_sinais:
            BOT2_LOGGER.warning("Nenhum job de sinal agendado! Reagendando...")
            bot2_iniciar_ciclo_sinais()
            return True
        else:
            BOT2_LOGGER.info(f"Encontrados {len(jobs_sinais)} jobs de sinais agendados")
            for job in jobs_sinais:
                BOT2_LOGGER.info(f"Job agendado: {job}")
            return True
    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao verificar agendamento de sinais: {str(e)}")
        traceback.print_exc()
        return False


def verificar_configuracoes_bot():
    """
    Verifica se as configurações do bot estão corretas.
    Retorna: True se tudo estiver correto, False caso contrário
    """
    global BOT2_TOKEN, BOT2_CANAIS_CONFIG, ATIVOS_CATEGORIAS, BOT2_LOGGER
    
    try:
        BOT2_LOGGER.info("Verificando configurações do bot...")
        
        # Verificar se o token foi configurado
        if not BOT2_TOKEN:
            BOT2_LOGGER.error("Token do bot não configurado!")
            return False
        BOT2_LOGGER.info(f"Token do bot configurado: {BOT2_TOKEN[:5]}...{BOT2_TOKEN[-5:]}")
        
        # Verificar se há canais configurados
        if not BOT2_CANAIS_CONFIG:
            BOT2_LOGGER.error("Nenhum canal configurado!")
            return False
            
        total_canais = sum(len(chats) for chats in BOT2_CANAIS_CONFIG.values())
        BOT2_LOGGER.info(f"Total de canais configurados: {total_canais}")
        
        # Verificar cada idioma
        for idioma, chats in BOT2_CANAIS_CONFIG.items():
            BOT2_LOGGER.info(f"Canais para idioma '{idioma}': {len(chats)}")
        
        # Verificar se há ativos configurados
        if not ATIVOS_CATEGORIAS or not ATIVOS_CATEGORIAS.get("Digital"):
            BOT2_LOGGER.error("Nenhum ativo configurado para a categoria Digital!")
            return False
            
        BOT2_LOGGER.info(f"Total de ativos na categoria 'Digital': {len(ATIVOS_CATEGORIAS['Digital'])}")
        
        # Testar a conexão com a API do Telegram
        BOT2_LOGGER.info("Testando conexão com a API do Telegram...")
        try:
            bot_info = bot2.get_me()
            BOT2_LOGGER.info(f"Conexão com API do Telegram OK! Bot: @{bot_info.username} ({bot_info.first_name})")
        except Exception as e:
            BOT2_LOGGER.error(f"Erro ao conectar com a API do Telegram: {str(e)}")
            BOT2_LOGGER.error("Verifique se o token está correto e se há conexão com a internet.")
            raise
        
        BOT2_LOGGER.info("Todas as configurações estão corretas!")
        
        return True
    except Exception as e:
        BOT2_LOGGER.error(f"Erro ao verificar configurações: {str(e)}")
        traceback.print_exc()
        return False


# Inicialização do sistema de envio de sinais
if __name__ == "__main__":
    BOT2_LOGGER.info("=== Iniciando sistema de envio de sinais ===")
    
    try:
        # Inicializar variáveis e configurações
        bot2_contador_sinais = 0
        bot2_sinais_agendados = False
        ultimo_sinal_enviado = None
        mensagem_perda_enviada_hoje = False
        
        # Testar a conexão com a API do Telegram
        BOT2_LOGGER.info("Testando conexão com a API do Telegram...")
        try:
            bot_info = bot2.get_me()
            BOT2_LOGGER.info(f"Conexão com API do Telegram OK! Bot: @{bot_info.username} ({bot_info.first_name})")
        except Exception as e:
            BOT2_LOGGER.error(f"Erro ao conectar com a API do Telegram: {str(e)}")
            BOT2_LOGGER.error("Verifique se o token está correto e se há conexão com a internet.")
            raise
        
        # Definir número máximo de tentativas de reinicialização
        max_retries = 5
        retry_count = 0
        retry_delay = 60  # segundos
        
        while retry_count < max_retries:
            try:
                BOT2_LOGGER.info(f"Tentativa {retry_count + 1} de {max_retries} para iniciar o bot")
                
                # Verificar configurações
                if not verificar_configuracoes_bot():
                    BOT2_LOGGER.error("Falha na verificação de configurações. Tentando novamente em 60 segundos...")
                    time.sleep(retry_delay)
                    retry_count += 1
                    continue
                
                # Verificar agendamento de sinais
                verificar_agendamento_sinais()
                
                # Iniciar o bot
                iniciar_ambos_bots()
                
                # Se chegarmos aqui, o bot está rodando normalmente
                BOT2_LOGGER.info("Bot iniciado com sucesso e em execução!")
                break
                
            except Exception as e:
                retry_count += 1
                BOT2_LOGGER.error(f"Erro ao iniciar o bot (tentativa {retry_count}): {str(e)}")
                BOT2_LOGGER.error(f"Tentando novamente em {retry_delay} segundos...")
                traceback.print_exc()
                time.sleep(retry_delay)
                
        if retry_count >= max_retries:
            BOT2_LOGGER.critical(f"Falha após {max_retries} tentativas. Verificar logs para detalhes.")
            sys.exit(1)
    
    except Exception as e:
        BOT2_LOGGER.error(f"Erro crítico ao iniciar o sistema: {str(e)}")
        traceback.print_exc()
        sys.exit(1)

def enviar_sequencia_multiplo_tres(sinal):
    """
    Gerencia a sequência especial para sinais múltiplos de 3.
    Envia: Sinal (T+0) → GIF pós-sinal (T+7) → Mensagem participação (T+27) → 
          GIF promocional (T+35) → Mensagem abertura (T+36)
    """
    try:
        # Limpar quaisquer agendamentos pendentes (por segurança)
        schedule.clear("abertura_corretora")
        
        # Identificador único para este sinal (baseado no timestamp)
        sinal_id = f"sinal_{bot2_contador_sinais}_{int(time.time())}"
        
        # Controle para garantir que cada etapa seja executada apenas uma vez
        etapas_concluidas = {
            "gif_pos_sinal": False,       # T+7
            "mensagem_participacao": False, # T+27
            "gif_promocional": False,      # T+35
            "mensagem_abertura": False     # T+36
        }
        
        # Registrar o tempo de início da sequência
        inicio_sequencia = bot2_obter_hora_brasilia()
        tempo_inicio = inicio_sequencia.strftime("%H:%M:%S")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] 🚀 INICIANDO SEQUÊNCIA MÚLTIPLA DE 3 (ID: {sinal_id})")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] 📋 Sequência programada: Sinal (T+0) → GIF pós-sinal (T+7) → Mensagem participação (T+27) → GIF promocional (T+35) → Mensagem abertura (T+36)")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] ⏱️ Hora de início da sequência: {inicio_sequencia.strftime('%Y-%m-%d %H:%M:%S')} (horário de Brasília)")
        
        # Verificar se o GIF pós-sinal já foi enviado
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] ✓ GIF pós-sinal (T+7): Já enviado pelo fluxo normal")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] 🔍 STATUS: Marcando GIF pós-sinal como concluído")
        etapas_concluidas["gif_pos_sinal"] = True
        
        # O GIF pós-sinal já foi enviado aos 7 minutos, como parte do fluxo normal
        # Agora esperamos 20 minutos desde o GIF pós-sinal para enviar a mensagem de participação
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] ⏲️ Aguardando 20 minutos após o GIF pós-sinal")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] ℹ️ Próximo passo: Mensagem participação em T+27min")
        
        # Calcular quanto tempo já passou desde o sinal original
        agora = bot2_obter_hora_brasilia()
        tempo_decorrido = (agora - inicio_sequencia).total_seconds()
        
        # Ajustar o tempo de espera se já tiver passado algum tempo
        tempo_espera_participacao = max(0, (27 * 60) - tempo_decorrido)
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] ⏱️ Tempo de espera ajustado: {tempo_espera_participacao:.1f} segundos")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] 🕒 Previsão de envio da mensagem de participação: {(inicio_sequencia + timedelta(seconds=27*60)).strftime('%H:%M:%S')}")
        
        if tempo_espera_participacao > 0:
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] 💤 Iniciando espera de {tempo_espera_participacao:.1f} segundos...")
            time.sleep(tempo_espera_participacao)
            BOT2_LOGGER.info(f"[SEQ-M3][{bot2_obter_hora_brasilia().strftime('%H:%M:%S')}] 🔄 Espera concluída para mensagem de participação")
        else:
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_inicio}] ⚡ Não é necessário esperar, tempo já passou")
        
        # Verificar novamente o tempo para garantir precisão
        if not etapas_concluidas["mensagem_participacao"]:
            # Enviar mensagem de participação em T+27
            agora = bot2_obter_hora_brasilia()
            tempo_atual = agora.strftime("%H:%M:%S")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⏰ Tempo de espera concluído (T+27)")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 📝 INICIANDO ENVIO DA MENSAGEM DE PARTICIPAÇÃO DA SESSÃO")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🕒 Hora atual: {agora.strftime('%Y-%m-%d %H:%M:%S')} (horário de Brasília)")
            
            try:
                # Chamada direta para a função de envio de mensagem de participação
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 📞 Chamando função enviar_mensagem_participacao()")
                resultado = enviar_mensagem_participacao()
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 📊 Resultado da função enviar_mensagem_participacao(): {resultado}")
                
                if resultado:
                    BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ✅ Mensagem de participação enviada com sucesso")
                    BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🔍 STATUS: Marcando mensagem de participação como concluída")
                    etapas_concluidas["mensagem_participacao"] = True
                else:
                    BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ❌ Falha ao enviar mensagem de participação")
                    BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ⚠️ A função enviar_mensagem_participacao() retornou False")
            except Exception as e:
                agora = bot2_obter_hora_brasilia()
                tempo_atual = agora.strftime("%H:%M:%S")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ❌ Erro ao enviar mensagem de participação: {str(e)}")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ⚠️ Exceção capturada durante o envio da mensagem de participação")
        else:
            BOT2_LOGGER.warning(f"[SEQ-M3][{tempo_atual}] ⚠️ Mensagem de participação já foi enviada, pulando esta etapa")
        
        # Aguardar até T+35 para enviar o GIF promocional
        # Total: 35 minutos após o sinal original
        agora = bot2_obter_hora_brasilia()
        tempo_atual = agora.strftime("%H:%M:%S")
        
        # Calcular quanto tempo já passou desde o início da sequência
        tempo_decorrido = (agora - inicio_sequencia).total_seconds()
        tempo_espera_gif_promo = max(0, (35 * 60) - tempo_decorrido)
        
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⏲️ Aguardando até T+35 para enviar GIF promocional")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⏱️ Tempo de espera ajustado: {tempo_espera_gif_promo:.1f} segundos")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🕒 Previsão de envio do GIF promocional: {(inicio_sequencia + timedelta(seconds=35*60)).strftime('%H:%M:%S')}")
        
        if tempo_espera_gif_promo > 0:
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 💤 Iniciando espera de {tempo_espera_gif_promo:.1f} segundos...")
            time.sleep(tempo_espera_gif_promo)
            BOT2_LOGGER.info(f"[SEQ-M3][{bot2_obter_hora_brasilia().strftime('%H:%M:%S')}] 🔄 Espera concluída para GIF promocional")
        else:
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⚡ Não é necessário esperar, tempo já passou")

        if not etapas_concluidas["gif_promocional"]:
            # Enviar GIF promo para cada idioma
            # Total: 35 minutos após o sinal original
            agora = bot2_obter_hora_brasilia()
            tempo_atual = agora.strftime("%H:%M:%S")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⏰ Tempo de espera concluído (T+35)")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🎬 INICIANDO ENVIO DO GIF PROMOCIONAL EM TODOS OS IDIOMAS")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🕒 Hora atual: {agora.strftime('%Y-%m-%d %H:%M:%S')} (horário de Brasília)")
            
            try:
                gifs_enviados = []
                
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🇧🇷 Enviando GIF promocional em Português")
                promo_pt = bot2_enviar_gif_promo(idioma="pt")
                gifs_enviados.append(promo_pt)
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ✅ GIF PT enviado: {promo_pt}")
                
                time.sleep(3)  # Pequeno delay entre mensagens para diferentes idiomas
                
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🇬🇧 Enviando GIF promocional em Inglês")
                promo_en = bot2_enviar_gif_promo(idioma="en")
                gifs_enviados.append(promo_en)
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ✅ GIF EN enviado: {promo_en}")
                
                time.sleep(3)
                
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🇪🇸 Enviando GIF promocional em Espanhol")
                promo_es = bot2_enviar_gif_promo(idioma="es")
                gifs_enviados.append(promo_es)
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ✅ GIF ES enviado: {promo_es}")
                
                if any(gifs_enviados):
                    BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ✅ Pelo menos um GIF promocional foi enviado com sucesso")
                    BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🔍 STATUS: Marcando GIF promocional como concluído")
                    etapas_concluidas["gif_promocional"] = True
                else:
                    BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ❌ Nenhum GIF promocional foi enviado com sucesso")
                    BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ⚠️ Todas as chamadas para bot2_enviar_gif_promo() retornaram False")
            except Exception as e:
                agora = bot2_obter_hora_brasilia()
                tempo_atual = agora.strftime("%H:%M:%S")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ❌ Erro ao enviar GIFs promocionais: {str(e)}")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ⚠️ Exceção capturada durante o envio dos GIFs promocionais")
        else:
            BOT2_LOGGER.warning(f"[SEQ-M3][{tempo_atual}] ⚠️ GIF promocional já foi enviado, pulando esta etapa")

        # Aguardar até T+36 para enviar mensagem de abertura da corretora
        # Total: 36 minutos após o sinal original
        agora = bot2_obter_hora_brasilia()
        tempo_atual = agora.strftime("%H:%M:%S")
        
        # Calcular quanto tempo já passou desde o início da sequência
        tempo_decorrido = (agora - inicio_sequencia).total_seconds()
        tempo_espera_mensagem_abertura = max(0, (36 * 60) - tempo_decorrido)
        
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⏲️ Aguardando até T+36 para enviar mensagem de abertura")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⏱️ Tempo de espera ajustado: {tempo_espera_mensagem_abertura:.1f} segundos")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🕒 Previsão de envio da mensagem de abertura: {(inicio_sequencia + timedelta(seconds=36*60)).strftime('%H:%M:%S')}")
        
        if tempo_espera_mensagem_abertura > 0:
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 💤 Iniciando espera de {tempo_espera_mensagem_abertura:.1f} segundos...")
            time.sleep(tempo_espera_mensagem_abertura)
            BOT2_LOGGER.info(f"[SEQ-M3][{bot2_obter_hora_brasilia().strftime('%H:%M:%S')}] 🔄 Espera concluída para mensagem de abertura")
        else:
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⚡ Não é necessário esperar, tempo já passou")

        if not etapas_concluidas["mensagem_abertura"]:
            # Enviar mensagem final de abertura da corretora
            # Total: 36 minutos após o sinal original
            agora = bot2_obter_hora_brasilia()
            tempo_atual = agora.strftime("%H:%M:%S")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ⏰ Tempo de espera concluído (T+36)")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 📝 INICIANDO ENVIO DA MENSAGEM DE ABERTURA DA CORRETORA")
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 🕒 Hora atual: {agora.strftime('%Y-%m-%d %H:%M:%S')} (horário de Brasília)")
            
            try:
                # Enviar a mensagem de abertura da corretora para todos os idiomas
                for idioma, chats in BOT2_CANAIS_CONFIG.items():
                    if not chats:
                        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ℹ️ Nenhum chat configurado para o idioma {idioma}, pulando")
                        continue
                        
                    # Obter a mensagem de abertura específica para o idioma
                    mensagem = get_mensagem_abertura_corretora(idioma)
                    
                    BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] 📤 Enviando mensagem de abertura para {len(chats)} chats no idioma {idioma}")
                    
                    for chat_id in chats:
                        try:
                            # Enviar a mensagem de abertura da corretora
                            resposta = bot2_send_message(
                                texto=mensagem,
                                chat_id=chat_id,
                                parse_mode="HTML"
                            )
                            
                            if resposta:
                                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ✅ Mensagem de abertura enviada para chat {chat_id} ({idioma})")
                            else:
                                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ❌ Falha ao enviar mensagem de abertura para chat {chat_id} ({idioma})")
                                
                        except Exception as e:
                            BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ❌ Erro ao enviar mensagem de abertura para chat {chat_id} ({idioma}): {str(e)}")
                            continue
                
                BOT2_LOGGER.info(f"[SEQ-M3][{tempo_atual}] ✅ Processo de envio da mensagem de abertura concluído")
                etapas_concluidas["mensagem_abertura"] = True
                
            except Exception as e:
                agora = bot2_obter_hora_brasilia()
                tempo_atual = agora.strftime("%H:%M:%S")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ❌ Erro ao enviar mensagem de abertura: {str(e)}")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
                BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ⚠️ Exceção capturada durante o envio da mensagem de abertura")
        else:
            BOT2_LOGGER.warning(f"[SEQ-M3][{tempo_atual}] ⚠️ Mensagem de abertura já foi enviada, pulando esta etapa")
        
        # Limpar novamente quaisquer agendamentos pendentes (por segurança)
        schedule.clear("abertura_corretora")
        
        # Calcular o tempo total da sequência
        fim_sequencia = bot2_obter_hora_brasilia()
        tempo_fim = fim_sequencia.strftime("%H:%M:%S")
        duracao_total = (fim_sequencia - inicio_sequencia).total_seconds() / 60.0
        
        # Verificar status de todas as etapas
        etapas_status = []
        for etapa, status in etapas_concluidas.items():
            etapas_status.append(f"{etapa}: {'✅' if status else '❌'}")
        
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_fim}] ✅ Sequência completa para múltiplo de 3 concluída")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_fim}] ⏱️ Duração total da sequência: {duracao_total:.1f} minutos")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_fim}] 📊 Status final das etapas: {', '.join(etapas_status)}")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_fim}] 📊 Resumo: Sinal (T+0) → GIF pós-sinal (T+7) → Mensagem participação (T+27) → GIF promocional (T+35) → Mensagem abertura (T+36)")
        BOT2_LOGGER.info(f"[SEQ-M3][{tempo_fim}] 🕒 Hora de início: {inicio_sequencia.strftime('%H:%M:%S')} | Hora de término: {fim_sequencia.strftime('%H:%M:%S')}")
        
        # Verificar se todas as etapas foram concluídas com sucesso
        todas_etapas_concluidas = all(etapas_concluidas.values())
        if todas_etapas_concluidas:
            BOT2_LOGGER.info(f"[SEQ-M3][{tempo_fim}] 🏆 TODAS AS ETAPAS FORAM EXECUTADAS COM SUCESSO!")
        else:
            BOT2_LOGGER.warning(f"[SEQ-M3][{tempo_fim}] ⚠️ ALERTA: Nem todas as etapas foram concluídas com sucesso. Verifique os logs para detalhes.")
            # Identificar quais etapas falharam
            for etapa, status in etapas_concluidas.items():
                if not status:
                    BOT2_LOGGER.error(f"[SEQ-M3][{tempo_fim}] ❌ Etapa '{etapa}' NÃO foi concluída com sucesso")
        
        return todas_etapas_concluidas
        
    except Exception as e:
        agora = bot2_obter_hora_brasilia()
        tempo_atual = agora.strftime("%H:%M:%S")
        BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ❌ Erro durante sequência de múltiplo de 3: {str(e)}")
        BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
        BOT2_LOGGER.error(f"[SEQ-M3][{tempo_atual}] ⚠️ SEQUÊNCIA INTERROMPIDA POR ERRO CRÍTICO")
        traceback.print_exc()
        return False

def get_mensagem_abertura_corretora(idioma="pt"):
    """
    Retorna a mensagem de abertura da corretora no idioma especificado.
    """
    mensagens = {
        "pt": """
👉🏼 Abram a corretora Pessoal

⚠️ FIQUEM ATENTOS ⚠️

🔥 Cadastre-se na XXBROKER agora mesmo 🔥

➡️ CLICANDO AQUI
""",
        "en": """
👉🏼 Open the broker now

⚠️ STAY ALERT ⚠️

🔥 Register on XXBROKER right now 🔥

➡️ CLICK HERE
""",
        "es": """
👉🏼 Abran la corretora ahora

⚠️ ATENCIÓN ⚠️

🔥 Regístrese en XXBROKER ahora mismo 🔥

➡️ HAGA CLIC AQUÍ
"""
    }
    
    # Retornar a mensagem no idioma solicitado, ou em português como fallback
    return mensagens.get(idioma, mensagens["pt"])

def bot2_gerar_e_enviar_sinal(ignorar_anti_duplicacao=False, enviar_gif_imediatamente=False):
    """Gera e envia um sinal de trading para os canais configurados."""
    global BOT2_LOGGER, BOT2_CANAIS_CONFIG, BOT2_TOKEN, CONFIGS_IDIOMA, ultimo_sinal_enviado, bot2_contador_sinais

    try:
        # Obtendo a hora atual de Brasília para logs
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        data_atual = agora.strftime("%Y-%m-%d")
        
        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🔄 Iniciando geração e envio de sinal (data: {data_atual})")
        
        # Verificar quais ativos estão disponíveis no momento
        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🔍 Verificando ativos disponíveis para este horário...")
        ativos_disponiveis = bot2_verificar_disponibilidade()
        
        # Log detalhado sobre ativos disponíveis
        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] ℹ️ Total de {len(ativos_disponiveis)} ativos disponíveis de {len(ATIVOS_CATEGORIAS['Digital'])} configurados")
        if len(ativos_disponiveis) < 5:
            BOT2_LOGGER.warning(f"[SINAL][{horario_atual}] ⚠️ Poucos ativos disponíveis: {', '.join(ativos_disponiveis)}")
        else:
            # Mostrar os primeiros ativos disponíveis (máximo 5) para não poluir o log
            ativos_amostra = ativos_disponiveis[:5]
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] ℹ️ Exemplos de ativos disponíveis: {', '.join(ativos_amostra)} e outros {len(ativos_disponiveis) - 5}...")
        
        # Adicionar os ativos disponíveis à categoria temporária
        ATIVOS_CATEGORIAS["Digital_Disponiveis"] = ativos_disponiveis
        
        # Gerar um sinal aleatório considerando apenas os ativos disponíveis
        sinal = bot2_gerar_sinal_aleatorio()
        if not sinal:
            BOT2_LOGGER.error(f"[SINAL][{horario_atual}] ❌ Falha ao gerar sinal aleatório")
            return False

        # Log do sinal gerado com mais detalhes
        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 📊 Sinal gerado: Ativo={sinal['ativo']}, Direção={sinal['direcao']}, Categoria={sinal['categoria']}, Tempo={sinal['tempo_expiracao_minutos']}min")
        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🕒 Horário exato de expiração: {(agora + timedelta(minutes=sinal['tempo_expiracao_minutos'])).strftime('%H:%M:%S')}")

        # Incrementar o contador de sinais (apenas se não estiver ignorando a anti-duplicação)
        if not ignorar_anti_duplicacao:
            bot2_contador_sinais += 1
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🔢 Contador incrementado: {bot2_contador_sinais}")
            if bot2_contador_sinais % 3 == 0:
                BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🎯 SINAL MÚLTIPLO DE 3 DETECTADO! Sequência especial será ativada.")
            else:
                BOT2_LOGGER.info(f"[SINAL][{horario_atual}] ℹ️ Sinal comum (não múltiplo de 3). Contador atual: {bot2_contador_sinais}")
        else:
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] ℹ️ Ignorando anti-duplicação, contador mantido: {bot2_contador_sinais}")

        ultimo_sinal_enviado = sinal

        # Para cada idioma configurado, envia a mensagem formatada
        sinais_enviados_com_sucesso = 0
        total_canais = 0
        
        for idioma, chats in BOT2_CANAIS_CONFIG.items():
            if not chats:  # Se não houver chats configurados para este idioma, pula
                BOT2_LOGGER.info(f"[SINAL][{horario_atual}] ℹ️ Nenhum chat configurado para o idioma {idioma}, pulando")
                continue

            # Obter a configuração para o idioma
            config_idioma = CONFIGS_IDIOMA.get(idioma, CONFIGS_IDIOMA["pt"])
            fuso_horario = config_idioma.get("fuso_horario")

            # Formatar a mensagem conforme o idioma
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 📝 Formatando mensagem para idioma {idioma} (fuso: {fuso_horario})")

            # Usar apenas hora e minuto para evitar problemas de formato
            mensagem = bot2_formatar_mensagem(sinal, agora.strftime("%H:%M"), idioma)
            if not mensagem:
                BOT2_LOGGER.error(f"[SINAL][{horario_atual}] ❌ Erro ao formatar mensagem para idioma {idioma}")
                continue

            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 📤 Enviando para {len(chats)} chat(s) no idioma {idioma}")
            
            for chat_id in chats:
                total_canais += 1
                try:
                    # URL base para a API do Telegram
                    url_base = f"https://api.telegram.org/bot{BOT2_TOKEN}/sendMessage"
                    
                    BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🚀 Enviando para chat_id: {chat_id}")
                    
                    # Iniciar contagem de tempo para calcular latência
                    tempo_inicio_envio = time.time()
                    
                    resposta = requests.post(
                        url_base,
                        json={
                            "chat_id": chat_id,
                            "text": mensagem,
                            "parse_mode": "HTML",
                            "disable_web_page_preview": True,
                        },
                        timeout=10,
                    )
                    
                    # Calcular latência
                    latencia = (time.time() - tempo_inicio_envio) * 1000  # em milissegundos

                    if resposta.status_code == 200:
                        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] ✅ Sinal enviado com sucesso para {chat_id} (latência: {latencia:.1f}ms)")
                        sinais_enviados_com_sucesso += 1
                    else:
                        BOT2_LOGGER.error(f"[SINAL][{horario_atual}] ❌ Erro ao enviar para {chat_id}: Status {resposta.status_code} - {resposta.text}")

                except Exception as e:
                    BOT2_LOGGER.error(f"[SINAL][{horario_atual}] ❌ Erro ao enviar para {chat_id}: {str(e)}")
                    BOT2_LOGGER.error(f"[SINAL][{horario_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")

        # Resumo do envio
        if total_canais > 0:
            taxa_sucesso = (sinais_enviados_com_sucesso / total_canais) * 100
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 📊 RESUMO: {sinais_enviados_com_sucesso}/{total_canais} sinais enviados com sucesso ({taxa_sucesso:.1f}%)")
        else:
            BOT2_LOGGER.warning(f"[SINAL][{horario_atual}] ⚠️ Nenhum canal configurado para envio de sinais!")

        # Agendar o envio do GIF pós-sinal 7 minutos após o sinal
        if enviar_gif_imediatamente:
            # Se solicitado, enviar o GIF imediatamente (para testes)
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🔄 Modo de teste: enviando GIF pós-sinal imediatamente")
            bot2_enviar_gif_pos_sinal(sinal)
        else:
            # Agendar o envio do GIF pós-sinal para 7 minutos após o envio do sinal
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] ⏱️ Agendando GIF pós-sinal para 7 minutos (T+7)")
            
            def enviar_gif_pos_sinal_apos_delay():
                try:
                    # Aguardar 7 minutos
                    inicio_espera = bot2_obter_hora_brasilia().strftime("%H:%M:%S")
                    BOT2_LOGGER.info(f"[GIF-DELAY][{inicio_espera}] ⏲️ Iniciando contagem de 7 minutos para o GIF pós-sinal")
                    time.sleep(420)  # 7 minutos = 420 segundos
                    
                    # Enviar o GIF pós-sinal
                    agora = bot2_obter_hora_brasilia()
                    horario_atual = agora.strftime("%H:%M:%S")
                    BOT2_LOGGER.info(f"[GIF-DELAY][{horario_atual}] ⏰ Tempo de espera concluído, enviando GIF pós-sinal (T+7)")
                    bot2_enviar_gif_pos_sinal(sinal)
                except Exception as e:
                    agora = bot2_obter_hora_brasilia()
                    horario_atual = agora.strftime("%H:%M:%S")
                    BOT2_LOGGER.error(f"[GIF-DELAY][{horario_atual}] ❌ Erro no agendamento do GIF pós-sinal: {str(e)}")
                    BOT2_LOGGER.error(f"[GIF-DELAY][{horario_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
                    traceback.print_exc()
            
            # Iniciar thread para envio do GIF pós-sinal
            gif_pos_sinal_thread = threading.Thread(target=enviar_gif_pos_sinal_apos_delay)
            gif_pos_sinal_thread.daemon = True
            gif_pos_sinal_thread.start()
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🧵 Thread para GIF pós-sinal iniciada com sucesso")

        # Verificar se é múltiplo de 3 para enviar a sequência especial
        e_multiplo_3 = bot2_contador_sinais % 3 == 0
        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🔢 Verificando se sinal #{bot2_contador_sinais} é múltiplo de 3: {e_multiplo_3}")
        
        if e_multiplo_3:
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🔄 Sinal múltiplo de 3 detectado (#{bot2_contador_sinais})")
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 📋 Iniciando sequência especial para múltiplos de 3")

            # Iniciar thread para executar a sequência especial de múltiplo de 3
            sequencia_thread = threading.Thread(target=lambda: enviar_sequencia_multiplo_tres(sinal))
            sequencia_thread.daemon = True
            sequencia_thread.start()
            BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 🧵 Thread para sequência de múltiplo de 3 iniciada com sucesso")

        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] ✅ Processamento do sinal concluído com sucesso")
        
        # Agendar a verificação do próximo sinal
        proximo_sinal = agora + timedelta(hours=1)
        proximo_sinal = proximo_sinal.replace(minute=13, second=0, microsecond=0)
        BOT2_LOGGER.info(f"[SINAL][{horario_atual}] 📅 Próximo sinal agendado para: {proximo_sinal.strftime('%H:%M:%S')} (horário de Brasília)")
        
        return True

    except Exception as e:
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        BOT2_LOGGER.error(f"[SINAL][{horario_atual}] ❌ Erro geral ao enviar sinal: {str(e)}")
        BOT2_LOGGER.error(f"[SINAL][{horario_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
        traceback.print_exc()
        return False

def enviar_mensagem_participacao():
    """
    Envia mensagens de participação para todos os canais configurados.
    Estas mensagens são enviadas 27 minutos após o sinal original.
    
    Retorna: True se pelo menos uma mensagem foi enviada com sucesso, False caso contrário.
    """
    global BOT2_LOGGER, BOT2_CANAIS_CONFIG, BOT2_TOKEN
    
    try:
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        BOT2_LOGGER.info(f"[PARTICIPACAO][{horario_atual}] 🔄 Iniciando envio de mensagens de participação")
        
        mensagens = {
            "pt": """
🔔 <b>AVISO IMPORTANTE</b> 🔔

⚠️ Participem ativamente da sessão!

💹 Aproveitem os sinais gratuitos e façam suas operações!

📝 Deixem seus comentários sobre os resultados obtidos.
""",
            "en": """
🔔 <b>IMPORTANT NOTICE</b> 🔔

⚠️ Actively participate in the session!

💹 Take advantage of free signals and make your operations!

📝 Leave your comments about the results obtained.
""",
            "es": """
🔔 <b>AVISO IMPORTANTE</b> 🔔

⚠️ ¡Participen activamente en la sesión!

💹 ¡Aprovechen las señales gratuitas y hagan sus operaciones!

📝 Dejen sus comentarios sobre los resultados obtenidos.
"""
        }
        
        mensagens_enviadas = 0
        total_canais = 0
        
        for idioma, chats in BOT2_CANAIS_CONFIG.items():
            if not chats:
                BOT2_LOGGER.info(f"[PARTICIPACAO][{horario_atual}] ℹ️ Nenhum chat configurado para o idioma {idioma}, pulando")
                continue
                
            mensagem = mensagens.get(idioma, mensagens["pt"])
            BOT2_LOGGER.info(f"[PARTICIPACAO][{horario_atual}] 📤 Enviando mensagem de participação para {len(chats)} chat(s) no idioma {idioma}")
            
            for chat_id in chats:
                total_canais += 1
                try:
                    # URL base para a API do Telegram
                    url_base = f"https://api.telegram.org/bot{BOT2_TOKEN}/sendMessage"
                    
                    resposta = requests.post(
                        url_base,
                        json={
                            "chat_id": chat_id,
                            "text": mensagem,
                            "parse_mode": "HTML",
                            "disable_web_page_preview": True,
                        },
                        timeout=10,
                    )
                    
                    if resposta.status_code == 200:
                        BOT2_LOGGER.info(f"[PARTICIPACAO][{horario_atual}] ✅ Mensagem de participação enviada com sucesso para {chat_id}")
                        mensagens_enviadas += 1
                    else:
                        BOT2_LOGGER.error(f"[PARTICIPACAO][{horario_atual}] ❌ Erro ao enviar mensagem de participação para {chat_id}: {resposta.text}")
                        
                except Exception as e:
                    BOT2_LOGGER.error(f"[PARTICIPACAO][{horario_atual}] ❌ Exceção ao enviar mensagem de participação para {chat_id}: {str(e)}")
                    BOT2_LOGGER.error(f"[PARTICIPACAO][{horario_atual}] 🔍 Detalhes: {traceback.format_exc()}")
        
        # Resumo do envio
        if total_canais > 0:
            taxa_sucesso = (mensagens_enviadas / total_canais) * 100
            BOT2_LOGGER.info(f"[PARTICIPACAO][{horario_atual}] 📊 RESUMO: {mensagens_enviadas}/{total_canais} mensagens enviadas com sucesso ({taxa_sucesso:.1f}%)")
        
        return mensagens_enviadas > 0
        
    except Exception as e:
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        BOT2_LOGGER.error(f"[PARTICIPACAO][{horario_atual}] ❌ Erro geral ao enviar mensagens de participação: {str(e)}")
        BOT2_LOGGER.error(f"[PARTICIPACAO][{horario_atual}] 🔍 Detalhes: {traceback.format_exc()}")
        return False

def bot2_enviar_gif_promo(idioma="pt"):
    """
    Envia um GIF promocional para os canais do idioma especificado.
    Este GIF é enviado 35 minutos após o sinal original (em sinais múltiplos de 3).
    
    Parâmetros:
        idioma (str): Idioma para o qual enviar o GIF ('pt', 'en', 'es')
        
    Retorna:
        bool: True se o GIF foi enviado com sucesso, False caso contrário
    """
    global BOT2_LOGGER, BOT2_CANAIS_CONFIG, BOT2_TOKEN
    
    try:
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        BOT2_LOGGER.info(f"[GIF-PROMO][{horario_atual}] 🎬 Iniciando envio de GIF promocional para idioma {idioma}")
        
        # URLs dos GIFs promocionais por idioma
        gif_urls = {
            "pt": "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExcXhscHdsMXdlaGJ4Y3EzYmE2Y2VldXN0N3BjOWF2c2t0eWF1amh3YiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Vbtc9VG51NtzT1Qnv1/giphy.gif",
            "en": "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExODljMnhvY3M1a242OXN5c2tzN2F2MnQwcXZlMThnbGN2bzZmYmU3ciZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/jTNG0CiVyNrFhJXWC3/giphy.gif",
            "es": "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExYTM2MzNpZW1jMnYyN2lrbXJuMnl1aHBhMG0yZ3NzZWhmdDRoenkzZiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/idGw983D7CHrrXa2eO/giphy.gif"
        }
        
        # Mensagens de acompanhamento para o GIF promocional
        mensagens = {
            "pt": "🔥 <b>RESULTADOS EXCLUSIVOS!</b> 🔥\n\nClique no botão abaixo para ver os resultados dos nossos alunos VIP!",
            "en": "🔥 <b>EXCLUSIVE RESULTS!</b> 🔥\n\nClick the button below to see the results of our VIP students!",
            "es": "🔥 <b>¡RESULTADOS EXCLUSIVOS!</b> 🔥\n\nHaga clic en el botón a continuación para ver los resultados de nuestros estudiantes VIP!"
        }
        
        # Botões inline para acompanhar o GIF
        botoes = {
            "pt": [{"text": "👉 VER RESULTADOS 👈", "url": "https://your-promo-link.com/pt"}],
            "en": [{"text": "👉 SEE RESULTS 👈", "url": "https://your-promo-link.com/en"}],
            "es": [{"text": "👉 VER RESULTADOS 👈", "url": "https://your-promo-link.com/es"}]
        }
        
        # Usar fallback para o idioma português se o idioma solicitado não existir
        gif_url = gif_urls.get(idioma, gif_urls["pt"])
        mensagem = mensagens.get(idioma, mensagens["pt"])
        botao = botoes.get(idioma, botoes["pt"])
        
        # Obter os canais para o idioma especificado
        chats = BOT2_CANAIS_CONFIG.get(idioma, [])
        if not chats:
            BOT2_LOGGER.warning(f"[GIF-PROMO][{horario_atual}] ⚠️ Nenhum chat configurado para o idioma {idioma}, pulando")
            return False
            
        BOT2_LOGGER.info(f"[GIF-PROMO][{horario_atual}] 📤 Enviando GIF promocional para {len(chats)} chat(s) no idioma {idioma}")
        
        gifs_enviados = 0
        
        for chat_id in chats:
            try:
                # Construir o teclado inline
                reply_markup = {
                    "inline_keyboard": [botao]
                }
                
                # URL base para a API do Telegram
                url_base = f"https://api.telegram.org/bot{BOT2_TOKEN}/sendAnimation"
                
                # Enviar o GIF promocional
                resposta = requests.post(
                    url_base,
                    json={
                        "chat_id": chat_id,
                        "animation": gif_url,
                        "caption": mensagem,
                        "parse_mode": "HTML",
                        "reply_markup": reply_markup
                    },
                    timeout=15,
                )
                
                if resposta.status_code == 200:
                    BOT2_LOGGER.info(f"[GIF-PROMO][{horario_atual}] ✅ GIF promocional enviado com sucesso para {chat_id}")
                    gifs_enviados += 1
                else:
                    BOT2_LOGGER.error(f"[GIF-PROMO][{horario_atual}] ❌ Erro ao enviar GIF promocional para {chat_id}: Status {resposta.status_code} - {resposta.text}")
                    
            except Exception as e:
                BOT2_LOGGER.error(f"[GIF-PROMO][{horario_atual}] ❌ Exceção ao enviar GIF promocional para {chat_id}: {str(e)}")
                BOT2_LOGGER.error(f"[GIF-PROMO][{horario_atual}] 🔍 Detalhes: {traceback.format_exc()}")
        
        # Resumo do envio
        taxa_sucesso = (gifs_enviados / len(chats)) * 100 if chats else 0
        BOT2_LOGGER.info(f"[GIF-PROMO][{horario_atual}] 📊 RESUMO: {gifs_enviados}/{len(chats)} GIFs enviados com sucesso ({taxa_sucesso:.1f}%)")
        
        return gifs_enviados > 0
        
    except Exception as e:
        agora = bot2_obter_hora_brasilia()
        horario_atual = agora.strftime("%H:%M:%S")
        BOT2_LOGGER.error(f"[GIF-PROMO][{horario_atual}] ❌ Erro geral ao enviar GIF promocional: {str(e)}")
        BOT2_LOGGER.error(f"[GIF-PROMO][{horario_atual}] 🔍 Detalhes do erro: {traceback.format_exc()}")
        return False
